use crate::{host_functions::native_rng, IdentityId, InvestorUid, Ticker};

use confidential_identity::{
    claim_proofs::Investor, CddClaimData, InvestorTrait as _, ScopeClaimData, ScopeClaimProof,
};

use codec::{Decode, Encode};
#[cfg(feature = "std")]
use sp_runtime::{Deserialize, Serialize};

/// Investor ZKProof generated by PIUS v2.
#[derive(Debug, Encode, Decode)]
#[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
pub struct InvestorZKProofData(pub ScopeClaimProof);

impl InvestorZKProofData {
    /// Generates the new ZKProof using PIUS v2.
    /// NB This proof uses an RNG input, so it is not deterministic.
    pub fn new(did: &IdentityId, investor: &InvestorUid, ticker: &Ticker) -> Self {
        let cdd_claim = Self::make_cdd_claim(did, investor);
        let scope_claim = Self::make_scope_claim(ticker.as_bytes(), investor);

        let mut rng = native_rng::Rng::default();
        let proof = Investor::create_scope_claim_proof(&cdd_claim, &scope_claim, &mut rng);

        Self(proof)
    }

    /// Returns the CDD claim of the given `did` and `investor`.
    pub fn make_cdd_claim(did: &IdentityId, investor: &InvestorUid) -> CddClaimData {
        CddClaimData::new(&did.to_bytes(), &investor.to_bytes())
    }

    /// Returns the Scope claim of the given `scope` and `investor_uid`.
    pub fn make_scope_claim(scope: &[u8], investor: &InvestorUid) -> ScopeClaimData {
        ScopeClaimData::new(scope, &investor.to_bytes())
    }

    /// Returns the Scope ID of the given `scope` and `investor_uid`.
    pub fn make_scope_id(scope: &[u8], investor: &InvestorUid) -> IdentityId {
        Self::make_scope_claim(scope, &investor)
            .scope_did
            .to_bytes()
            .into()
    }
}
