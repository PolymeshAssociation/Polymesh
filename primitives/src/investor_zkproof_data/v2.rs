use crate::{host_functions::native_rng, IdentityId, InvestorUid, Ticker};

use codec::{Decode, Encode};
use confidential_identity::{
    claim_proofs::{slice_to_ristretto_point, slice_to_scalar, Investor},
    CddClaimData, InvestorTrait as _, ScopeClaimData, ScopeClaimProof,
};
use scale_info::TypeInfo;
#[cfg(feature = "std")]
use sp_runtime::{Deserialize, Serialize};

/// Investor ZKProof generated by PIUS v2.
#[derive(Debug, Encode, TypeInfo, Decode, Clone, Copy)]
#[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
pub struct InvestorZKProofData(pub ScopeClaimProof);

impl InvestorZKProofData {
    /// Generates the new ZKProof using PIUS v2.
    /// NB This proof uses an RNG input, so it is not deterministic.
    pub fn new(did: &IdentityId, investor: &InvestorUid, ticker: &Ticker) -> Self {
        let cdd_claim = Self::make_cdd_claim(did, investor);
        let scope_claim = Self::make_scope_claim(ticker.as_bytes(), investor);
        let mut rng = native_rng::Rng::default();

        Self(Investor::create_scope_claim_proof(
            &cdd_claim,
            &scope_claim,
            &mut rng,
        ))
    }

    /// Returns the CDD claim of the given `did` and `investor`.
    pub fn make_cdd_claim(did: &IdentityId, investor: &InvestorUid) -> CddClaimData {
        CddClaimData::new(&did.to_bytes(), &investor.to_bytes())
    }

    /// Returns the Scope claim of the given `scope` and `investor_uid`.
    pub fn make_scope_claim(scope: &[u8], investor: &InvestorUid) -> ScopeClaimData {
        ScopeClaimData::new(scope, &investor.to_bytes())
    }

    /// Returns the Scope ID of the given `scope` and `investor_uid`.
    pub fn make_scope_id(scope: &[u8], investor: &InvestorUid) -> IdentityId {
        let scope_did = slice_to_ristretto_point(slice_to_scalar(scope).as_bytes());
        let investor = slice_to_scalar(investor.as_slice());
        let scope_id = investor * scope_did;

        scope_id.compress().to_bytes().into()
    }
}
