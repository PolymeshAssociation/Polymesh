// This file is part of the Polymesh distribution (https://github.com/PolymathNetwork/Polymesh).
// Copyright (c) 2020 Polymath

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, version 3.

// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

//! # Identity module
//!
//! This module is used to manage identity concept.
//!
//!  - [Module](./struct.Module.html)
//!  - [Trait](./trait.Trait.html)
//!
//! ## Overview :
//!
//! Identity concept groups different account (keys) in one place, and it allows each key to
//! make operations based on the constraint that each account (permissions and key types).
//!
//! Any account can create and manage one and only one identity, using
//! [register_did](./struct.Module.html#method.register_did). Other accounts can be added to a
//! target identity as secondary key, where we also define the type of account (`External`,
//! `MultiSign`, etc.) and/or its permission.
//!
//! Some operations at identity level are only allowed to its administrator account, like
//! [set_primary_key](./struct.Module.html#method.set_primary_key) or
//!
//! ## Identity information
//!
//! Identity contains the following data:
//!  - `primary_key`. It is the administrator account of the identity.
//!  - `secondary_keys`. List of keys and their capabilities (type of key and its permissions) .
//!
//! ## Freeze secondary keys
//!
//! It is an *emergency action* to block all secondary keys of an identity and it can only be performed
//! by its administrator.
//!
//! see [freeze_secondary_keys](./struct.Module.html#method.freeze_secondary_keys)
//! see [unfreeze_secondary_keys](./struct.Module.html#method.unfreeze_secondary_keys)
//!
//! ## Interface
//!
//! ### Dispatchable Functions
//!
//! - `register_did` - Register a new did with a CDD claim for the caller.
//! - `cdd_register_did` - Registers a new did for the target and attaches a CDD claim to it.
//! - `invalidate_cdd_claims` - Invalidates any claim generated by `cdd` from `disable_from` timestamps.
//! - `remove_secondary_keys` - Removes specified secondary keys of a DID if present.
//! - `set_primary_key` - Sets a new primary key for a DID.
//! - `accept_primary_key` - Accept authorization to become the new primary key of an identity.
//! - `change_cdd_requirement_for_mk_rotation` - Sets if CDD authorization is required for updating primary key of an identity.
//! - `join_identity_as_key` - Join an identity as a secondary key.
//! - `join_identity_as_identity` - Join an identity as a secondary identity.
//! - `add_claim` - Adds a new claim record or edits an existing one.
//! - `batch_add_claim` - Adds a new batch of claim records or edits an existing one.
//! - `forwarded_call` - Creates a call on behalf of another DID.
//! - `revoke_claim` - Marks the specified claim as revoked.
//! - `batch_revoke_claim` - Revokes multiple claims in a batch.
//! - `set_permission_to_signer` - Sets permissions for an specific `target_key` key.
//! - `freeze_secondary_keys` - Disables all secondary keys at `did` identity.
//! - `unfreeze_secondary_keys` - Re-enables all secondary keys of the caller's identity.
//! - `add_authorization` - Adds an authorization.
//! - `batch_add_authorization` - Adds an array of authorizations.
//! - `remove_authorization` - Removes an authorization.
//! - `batch_remove_authorization` - Removes an array of authorizations.
//! - `accept_authorization` - Accepts an authorization.
//! - `batch_accept_authorization` - Accepts an array of authorizations.
//! - `batch_add_secondary_key_with_authorization` - Adds secondary keys to target identity `id`.
//! - `revoke_offchain_authorization` - Revokes the `auth` off-chain authorization of `signer`.

#![cfg_attr(not(feature = "std"), no_std)]
#![recursion_limit = "256"]

pub mod types;
pub use types::{DidRecords as RpcDidRecords, DidStatus};

#[cfg(feature = "runtime-benchmarks")]
pub mod benchmarking;

use codec::{Decode, Encode};
use core::{
    convert::{From, TryInto},
    result::Result as StdResult,
};
use polymesh_common_utilities::{
    constants::did::{SECURITY_TOKEN, USER},
    protocol_fee::{ChargeProtocolFee, ProtocolOp},
    traits::{
        asset::AcceptTransfer,
        group::{GroupTrait, InactiveMember},
        identity::{
            AuthorizationNonce, IdentityTrait, LinkedKeyInfo, RawEvent, SecondaryKeyWithAuth,
            TargetIdAuthorization, Trait,
        },
        multisig::MultiSigSubTrait,
        portfolio::PortfolioSubTrait,
        transaction_payment::{CddAndFeeDetails, ChargeTxFee},
    },
    with_each_transaction, Context, SystematicIssuers,
};
use polymesh_primitives::{
    AuthIdentifier, Authorization, AuthorizationData, AuthorizationError, AuthorizationType, CddId,
    Claim, ClaimType, Identity as DidRecord, IdentityClaim, IdentityId, InvestorUid, Permission,
    Scope, SecondaryKey, Signatory, Ticker,
};
use sp_core::sr25519::Signature;
use sp_io::hashing::blake2_256;
use sp_runtime::{
    traits::{
        AccountIdConversion, CheckedAdd, Dispatchable, Hash, IdentifyAccount, SaturatedConversion,
        Verify, Zero,
    },
    AnySignature,
};
use sp_std::{convert::TryFrom, mem::swap, prelude::*, vec};

use frame_support::{
    debug, decl_error, decl_module, decl_storage,
    dispatch::{DispatchError, DispatchResult, DispatchResultWithPostInfo},
    ensure,
    traits::{ChangeMembers, Currency, InitializeMembers},
    weights::{DispatchClass, GetDispatchInfo, Pays, Weight},
    Blake2_128Concat, ReversibleStorageHasher, StorageDoubleMap,
};
use frame_system::{self as system, ensure_root, ensure_signed};

pub type Event<T> = polymesh_common_utilities::traits::identity::Event<T>;

#[derive(Encode, Decode, Clone, PartialEq, Eq, Debug, PartialOrd, Ord)]
pub struct Claim1stKey {
    pub target: IdentityId,
    pub claim_type: ClaimType,
}

#[derive(Encode, Decode, Clone, PartialEq, Eq, Debug, PartialOrd, Ord)]
pub struct Claim2ndKey {
    pub issuer: IdentityId,
    pub scope: Option<Scope>,
}

#[derive(Encode, Decode, Clone, PartialEq, Eq, Default, Debug)]
pub struct BatchAddClaimItem<M> {
    pub target: IdentityId,
    pub claim: Claim,
    pub expiry: Option<M>,
}

#[derive(Encode, Decode, Clone, PartialEq, Eq, Default, Debug)]
pub struct BatchRevokeClaimItem {
    pub target: IdentityId,
    pub claim: Claim,
}

decl_storage! {
    trait Store for Module<T: Trait> as identity {

        /// DID -> identity info
        pub DidRecords get(fn did_records) config(): map hasher(twox_64_concat) IdentityId => DidRecord<T::AccountId>;

        /// DID -> bool that indicates if secondary keys are frozen.
        pub IsDidFrozen get(fn is_did_frozen): map hasher(twox_64_concat) IdentityId => bool;

        /// It stores the current identity for current transaction.
        pub CurrentDid: Option<IdentityId>;

        /// It stores the current gas fee payer for the current transaction
        pub CurrentPayer: Option<T::AccountId>;

        /// (Target ID, claim type) (issuer,scope) -> Associated claims
        pub Claims: double_map hasher(blake2_128_concat) Claim1stKey, hasher(blake2_128_concat) Claim2ndKey => IdentityClaim;

        // Account => DID
        pub KeyToIdentityIds get(fn key_to_identity_ids) config(): map hasher(blake2_128_concat) T::AccountId => Option<LinkedKeyInfo>;

        /// Nonce to ensure unique actions. starts from 1.
        pub MultiPurposeNonce get(fn multi_purpose_nonce) build(|_| 1u64): u64;

        /// Authorization nonce per Identity. Initially is 0.
        pub OffChainAuthorizationNonce get(fn offchain_authorization_nonce): map hasher(twox_64_concat) IdentityId => AuthorizationNonce;

        /// Inmediate revoke of any off-chain authorization.
        pub RevokeOffChainAuthorization get(fn is_offchain_authorization_revoked):
            map hasher(blake2_128_concat) (Signatory<T::AccountId>, TargetIdAuthorization<T::Moment>) => bool;

        /// All authorizations that an identity/key has
        pub Authorizations: double_map hasher(blake2_128_concat)
            Signatory<T::AccountId>, hasher(twox_64_concat) u64 => Authorization<T::AccountId, T::Moment>;

        /// All authorizations that an identity has given. (Authorizer, auth_id -> authorized)
        pub AuthorizationsGiven: double_map hasher(blake2_128_concat)
            IdentityId, hasher(twox_64_concat) u64 => Signatory<T::AccountId>;

        /// Obsoleted storage variable superceded by `CddAuthForPrimaryKeyRotation`. It is kept here
        /// for the purpose of storage migration.
        pub CddAuthForMasterKeyRotation get(fn cdd_auth_for_master_key_rotation): bool;

        /// A config flag that, if set, instructs an authorization from a CDD provider in order to
        /// change the primary key of an identity.
        pub CddAuthForPrimaryKeyRotation get(fn cdd_auth_for_primary_key_rotation): bool;
    }
    add_extra_genesis {
        config(identities): Vec<(T::AccountId, IdentityId, IdentityId, InvestorUid, Option<u64>)>;
        config(secondary_keys): Vec<(T::AccountId, IdentityId)>;
        build(|config: &GenesisConfig<T>| {
            use polymesh_common_utilities::SYSTEMATIC_ISSUERS;

            SYSTEMATIC_ISSUERS.iter()
                .for_each(|s| <Module<T>>::register_systematic_id(*s));

            // Add CDD claims to Treasury & BRR
            let sys_issuers_with_cdd = [SystematicIssuers::Treasury, SystematicIssuers::BlockRewardReserve, SystematicIssuers::Settlement];
            let id_with_cdd = sys_issuers_with_cdd.iter()
                .inspect(|iss| debug::info!( "Add Systematic CDD Claims to {}", iss))
                .map(|iss| iss.as_id())
                .collect::<Vec<_>>();

            <Module<T>>::add_systematic_cdd_claims( &id_with_cdd, SystematicIssuers::CDDProvider);

            //  Other
            for &(ref primary_account_id, issuer, did, investor_uid, expiry) in &config.identities {
                let cdd_claim = Claim::CustomerDueDiligence(CddId::new( did.clone(), investor_uid));
                // Direct storage change for registering the DID and providing the claim
                <Module<T>>::ensure_no_id_record(did).unwrap();
                <MultiPurposeNonce>::mutate(|n| *n += 1_u64);
                let expiry = expiry.iter().map(|m| T::Moment::from(*m as u32)).next();
                <Module<T>>::unsafe_register_id(primary_account_id.clone(), did);
                <Module<T>>::base_add_claim( did, cdd_claim, issuer, expiry);
            }

            for &(ref signer_id, did) in &config.secondary_keys {
                // Direct storage change for attaching some secondary keys to identities
                <Module<T>>::ensure_id_record_exists(did).unwrap();
                assert!(
                    <Module<T>>::can_key_be_linked_to_did(&signer_id),
                    "Secondary key already linked"
                );
                <MultiPurposeNonce>::mutate(|n| *n += 1_u64);
                <Module<T>>::link_key_to_did(&signer_id, did);
                <DidRecords<T>>::mutate(did, |record| {
                    (*record).add_secondary_keys(&[SecondaryKey::from_account_id(signer_id.clone())]);
                });
                <Module<T>>::deposit_event(RawEvent::SecondaryKeysAdded(
                    did,
                    [SecondaryKey::from_account_id(signer_id.clone())].to_vec(),
                ));
            }
        });
    }
}

decl_module! {
    /// The module declaration.
    pub struct Module<T: Trait> for enum Call where origin: T::Origin {

        type Error = Error<T>;

        // Initializing events
        // this is needed only if you are using events in your module
        fn deposit_event() = default;

        // TODO: Remove this function before mainnet. cdd_register_did should be used instead.
        /// Register a new did with a CDD claim for the caller.
        #[weight = 5_000_000_000]
        pub fn register_did(origin,
            uid: InvestorUid,
            secondary_keys: Vec<SecondaryKey<T::AccountId>>,
        ) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            Self::_register_did(sender.clone(), secondary_keys, Some(ProtocolOp::IdentityRegisterDid))?;

            // Add CDD claim
            let did = Self::get_identity(&sender).ok_or_else(|| "DID Self-register failed")?;
            let cdd_claim = Claim::CustomerDueDiligence(CddId::new(did, uid));
            Self::base_add_claim(did, cdd_claim, did, None);

            Ok(())
        }

        /// Register `target_account` with a new Identity.
        ///
        /// # Failure
        /// - `origin` has to be a active CDD provider. Inactive CDD providers cannot add new
        /// claims.
        /// - `target_account` (primary key of the new Identity) can be linked to just one and only
        /// one identity.
        /// - External secondary keys can be linked to just one identity.
        ///
        /// # Weight
        /// `7_000_000_000 + 600_000 * secondary_keys.len()`
        #[weight = (
            (7_000_000_000 + 600_000 * u64::try_from(secondary_keys.len()).unwrap_or_default()),
            DispatchClass::Normal,
            Pays::Yes
        )]
        pub fn cdd_register_did(
            origin,
            target_account: T::AccountId,
            secondary_keys: Vec<SecondaryKey<T::AccountId>>
        ) -> DispatchResult {
            let cdd_sender = ensure_signed(origin)?;
            let cdd_id = Context::current_identity_or::<Self>(&cdd_sender)?;
            Self::base_cdd_register_did(cdd_id, target_account, secondary_keys)?;
            Ok(())
        }

        // TODO: Remove this before mainnet.
        /// Registers a new Identity for the `target_account` and issues a CDD claim to it.
        ///
        /// # Failure
        /// - `origin` has to be a active CDD provider. Inactive CDD providers cannot add new
        /// claims.
        /// - `target_account` (primary key of the new Identity) can be linked to just one and only
        /// one identity.
        ///
        /// # Weight
        /// `7_000_000_000
        #[weight = (7_000_000_000, DispatchClass::Normal, Pays::Yes)]
        pub fn mock_cdd_register_did(
            origin,
            target_account: T::AccountId,
        ) -> DispatchResult {
            let cdd_sender = ensure_signed(origin)?;
            let cdd_id = Context::current_identity_or::<Self>(&cdd_sender)?;
            let target_did = Self::base_cdd_register_did(cdd_id, target_account, vec![])?;

            // Add CDD claim for the target
            let cdd_claim = Claim::CustomerDueDiligence(CddId::new(target_did, target_did.to_bytes().into()));
            Self::base_add_claim(target_did, cdd_claim, cdd_id, None);

            Ok(())
        }

        /// It invalidates any claim generated by `cdd` from `disable_from` timestamps.
        /// You can also define an expiration time, which will invalidate all claims generated by
        /// that `cdd` and remove it as CDD member group.
        #[weight = 850_000_000]
        pub fn invalidate_cdd_claims(
            origin,
            cdd: IdentityId,
            disable_from: T::Moment,
            expiry: Option<T::Moment>,
        ) -> DispatchResult {
            ensure_root(origin)?;

            let now = <pallet_timestamp::Module<T>>::get();
            ensure!(
                T::CddServiceProviders::get_valid_members_at(now).contains(&cdd),
                Error::<T>::UnAuthorizedCddProvider);

            T::CddServiceProviders::disable_member(cdd, expiry, Some(disable_from))?;
            Self::deposit_event(RawEvent::CddClaimsInvalidated(cdd, disable_from));
            Ok(())
        }

        /// Removes specified secondary keys of a DID if present.
        ///
        /// # Failure
        /// It can only called by primary key owner.
        ///
        /// # Weight
        /// `950_000_000 + 60_000 * signers_to_remove.len()`
        #[weight = (
            950_000_000 + 60_000 * u64::try_from(signers_to_remove.len()).unwrap_or_default(),
            DispatchClass::Normal,
            Pays::Yes
        )]
        pub fn remove_secondary_keys(origin, signers_to_remove: Vec<Signatory<T::AccountId>>) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            let did = Context::current_identity_or::<Self>(&sender)?;
            let _grants_checked = Self::grant_check_only_primary_key(&sender, did)?;

            // Remove links and get all authorization IDs per signer.
            let signer_and_auth_id_list = signers_to_remove.iter().filter_map(|signer| {
                if let Signatory::Account(key) = &signer {
                    if T::MultiSig::is_multisig(key) {
                        if !T::Balances::total_balance(key).is_zero() {
                            return None;
                        }
                        // Unlink multisig signers from the identity.
                        Self::unlink_multisig_signers_from_did(
                            T::MultiSig::get_key_signers(key),
                            did
                        );
                    }
                    Self::unlink_key_from_did(key, did)
                }

                // It returns the list of `auth_id` from `did`.
                let auth_ids = <Authorizations<T>>::iter_prefix_values(signer)
                    .filter_map( |authorization| {
                        if authorization.authorized_by == did {
                            Some(authorization.auth_id)
                        } else {
                            None
                        }
                    })
                    .collect::<Vec<_>>();

                Some((signer, auth_ids))
            })
            .collect::<Vec<_>>();

            // Remove authorizations
            signer_and_auth_id_list.into_iter().for_each( |(signer, auth_ids)| {
                auth_ids.into_iter().for_each( |auth_id|
                        Self::unsafe_remove_auth( signer, auth_id, &did, true));
            });

            // Update secondary keys at Identity.
            <DidRecords<T>>::mutate(did, |record| {
                (*record).remove_secondary_keys(&signers_to_remove);
            });

            Self::deposit_event(RawEvent::SecondaryKeysRemoved(did, signers_to_remove));
            Ok(())
        }

        /// Sets a new primary key for a DID.
        ///
        /// # Failure
        /// Only called by primary key owner.
        #[weight = 800_000_000]
        fn set_primary_key(origin, new_key: T::AccountId) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            let did = Context::current_identity_or::<Self>(&sender)?;
            let _grants_checked = Self::grant_check_only_primary_key(&sender, did)?;

            ensure!(
                Self::can_key_be_linked_to_did(&new_key),
                Error::<T>::AlreadyLinked
            );
            T::ProtocolFee::charge_fee(ProtocolOp::IdentitySetPrimaryKey)?;
            <DidRecords<T>>::mutate(did, |record| {
                (*record).primary_key = new_key.clone();
            });

            Self::deposit_event(RawEvent::PrimaryKeyUpdated(did, sender, new_key));
            Ok(())
        }

        /// Call this with the new primary key. By invoking this method, caller accepts authorization
        /// with the new primary key. If a CDD service provider approved this change, primary key of
        /// the DID is updated.
        ///
        /// # Arguments
        /// * `owner_auth_id` Authorization from the owner who initiated the change
        /// * `cdd_auth_id` Authorization from a CDD service provider
        #[weight = 900_000_000]
        pub fn accept_primary_key(origin, rotation_auth_id: u64, optional_cdd_auth_id: Option<u64>) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            Self::accept_primary_key_rotation(sender, rotation_auth_id, optional_cdd_auth_id)
        }

        /// Set if CDD authorization is required for updating primary key of an identity.
        /// Callable via root (governance)
        ///
        /// # Arguments
        /// * `auth_required` CDD Authorization required or not
        #[weight = 800_000_000]
        pub fn change_cdd_requirement_for_mk_rotation(
            origin,
            auth_required: bool,
        ) -> DispatchResult {
            ensure_root(origin)?;
            <CddAuthForPrimaryKeyRotation>::put(auth_required);
            Self::deposit_event(RawEvent::CddRequirementForPrimaryKeyUpdated(auth_required));
            Ok(())
        }

        /// Join an identity as a secondary key.
        #[weight = 800_000_000]
        pub fn join_identity_as_key(origin, auth_id: u64) -> DispatchResult {
            let signer = Signatory::Account(ensure_signed(origin)?);
            Self::join_identity(signer, auth_id)
        }

        /// Join an identity as a secondary identity.
        #[weight = 800_000_000]
        pub fn join_identity_as_identity(origin, auth_id: u64) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            let sender_did = Context::current_identity_or::<Self>(&sender)?;
            Self::join_identity(Signatory::from(sender_did), auth_id)
        }

        /// Leave the secondary key's identity.
        #[weight = 800_000_000]
        pub fn leave_identity_as_key(origin) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            if let Some(did) = Self::get_identity(&sender) {
                return Self::leave_identity(Signatory::Account(sender), did);
            }
            Ok(())
        }

        /// Leave an identity as a secondary identity.
        #[weight = 800_000_000]
        pub fn leave_identity_as_identity(origin, did: IdentityId) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            let sender_did = Context::current_identity_or::<Self>(&sender)?;
            Self::leave_identity(Signatory::from(sender_did), did)
        }

        /// Adds a new claim record or edits an existing one. Only called by did_issuer's secondary key.
        #[weight = 950_000_000]
        pub fn add_claim(
            origin,
            target: IdentityId,
            claim: Claim,
            expiry: Option<T::Moment>,
        ) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            let issuer = Context::current_identity_or::<Self>(&sender)?;
            ensure!(<DidRecords<T>>::contains_key(target), Error::<T>::DidMustAlreadyExist);

            match &claim {
                Claim::CustomerDueDiligence(..) => Self::base_add_cdd_claim(target, claim, issuer, expiry)?,
                Claim::InvestorZKProof(_t, _s, cdd_id, _p) => {
                    Self::base_add_confidential_scope_claim(
                        target,
                        claim.clone(),
                        issuer,
                        expiry,
                        cdd_id.clone())?
                },
                _ => {
                    T::ProtocolFee::charge_fee(ProtocolOp::IdentityAddClaim)?;
                    Self::base_add_claim(target, claim, issuer, expiry)
                }
            };
            Ok(())
        }

        /// Adds a new batch of claim records or edits an existing one. Only called by
        /// `did_issuer`'s secondary key.
        ///
        /// # Weight
        /// `950_000_000 + 1_000_000 * claims.len()`
        #[weight =(
            950_000_000 + 1_000_000 * u64::try_from(claims.len()).unwrap_or_default(),
            DispatchClass::Normal,
            Pays::Yes
        )]
        pub fn batch_add_claim(
            origin,
            claims: Vec<BatchAddClaimItem<T::Moment>>
        ) -> DispatchResult {
            ensure_signed(origin.clone())?;
            with_each_transaction(claims, |bci| {
                Self::add_claim(origin.clone(), bci.target, bci.claim, bci.expiry)
            })
        }

        /// Creates a call on behalf of another DID.
        #[weight =(
            500_000_000 + proposal.get_dispatch_info().weight,
            proposal.get_dispatch_info().class,
            Pays::Yes
        )]
        fn forwarded_call(origin, target_did: IdentityId, proposal: Box<T::Proposal>) -> DispatchResultWithPostInfo {
            let sender = ensure_signed(origin)?;

            // 1. Constraints.
            // 1.1. A valid current identity.
            let current_did = Context::current_identity::<Self>()
                .ok_or_else(||Error::<T>::MissingCurrentIdentity)?;

            // 1.2. Check that current_did is a secondary key of target_did
            ensure!(
                Self::is_signer_authorized(current_did, &Signatory::Identity(target_did)),
                Error::<T>::CurrentIdentityCannotBeForwarded
            );

            // 1.3. Check that target_did has a CDD.
            ensure!(Self::has_valid_cdd(target_did), Error::<T>::TargetHasNoCdd);

            // 1.4 charge fee
            let _ = T::ChargeTxFeeTarget::charge_fee(
                proposal.encode().len().try_into().unwrap_or_default(),
                proposal.get_dispatch_info())
                    .map_err(|_| Error::<T>::FailedToChargeFee)?;

            // 2. Actions
            T::CddHandler::set_current_identity(&target_did);

            // Also set current_did roles when acting as a secondary key for target_did
            // Re-dispatch call - e.g. to asset::doSomething...
            let new_origin = frame_system::RawOrigin::Signed(sender).into();

            let actual_weight = match proposal.dispatch(new_origin) {
                Ok(post_info) => post_info.actual_weight,
                Err(err) => err.post_info.actual_weight,
            };

            // If actual_weight retrieve from the proposal is `None` then refunds = 0
            // otherwise refunds = ((500_000_000 + proposal.get_dispatch_info().weight) - `actual_weight of proposal + 500_000_000`).
            Ok((actual_weight.map(|w| w + 500_000_000)).into())
        }

        /// Marks the specified claim as revoked.
        #[weight = 500_000_000]
        pub fn revoke_claim(origin,
            target: IdentityId,
            claim: Claim,
        ) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            let issuer = Context::current_identity_or::<Self>(&sender)?;
            let claim_type = claim.claim_type();
            let scope = claim.as_scope().cloned();

            match &claim {
                Claim::InvestorZKProof(..) => Self::revoke_confidential_scope_claim(target, claim_type, issuer, scope),
                _ => {
                    Self::base_revoke_claim(target, claim_type, issuer, scope);
                    Ok(())
                }
            }
        }

        /// Revoke multiple claims in a batch.
        ///
        /// # Arguments
        /// * origin - did issuer
        /// * did_and_claim_data - Vector of the identities & the corresponding claim data whom claim needs to be revoked
        ///
        /// # Weight
        /// `500_000_000 + 150_000 * claims.len()`
        #[weight = (
            500_000_000 + 150_000 * u64::try_from(claims.len()).unwrap_or_default(),
            DispatchClass::Normal,
            Pays::Yes
        )]
        pub fn batch_revoke_claim(
            origin,
            claims: Vec<BatchRevokeClaimItem>
        ) -> DispatchResult {
            let _sender = ensure_signed(origin.clone())?;
            with_each_transaction(claims, |bci| {
                Self::revoke_claim(origin.clone(), bci.target, bci.claim)
            })
        }

        /// It sets permissions for an specific `target_key` key.
        /// Only the primary key of an identity is able to set secondary key permissions.
        ///
        /// # Weight
        /// `600_000_000 + 300_000 * permissions.len()`
        #[weight =(
            600_000_000 + 300_000 * u64::try_from(permissions.len()).unwrap_or_default(),
            DispatchClass::Normal,
            Pays::Yes
        )]
        pub fn set_permission_to_signer(
            origin,
            signer: Signatory<T::AccountId>,
            permissions: Vec<Permission>
        ) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            let did = Context::current_identity_or::<Self>(&sender)?;
            let record = Self::grant_check_only_primary_key(&sender, did)?;

            // You are trying to add a permission to did's primary key. It is not needed.
            match signer {
                Signatory::Account(ref key) if record.primary_key == *key => Ok(()),
                _ if record.secondary_keys.iter().any(|si| si.signer == signer) => Self::update_secondary_key_permissions(did, &signer, permissions),
                _ => Err(Error::<T>::InvalidSender.into()),
            }
        }

        /// It disables all secondary keys at `did` identity.
        ///
        /// # Errors
        ///
        #[weight = 700_000_000]
        pub fn freeze_secondary_keys(origin) -> DispatchResult {
            Self::set_frozen_secondary_key_flags(origin, true)
        }

        /// Re-enables all secondary keys of the caller's identity.
        #[weight = 700_000_000]
        pub fn unfreeze_secondary_keys(origin) -> DispatchResult {
            Self::set_frozen_secondary_key_flags(origin, false)
        }

        // TODO: Remove before mainnet launch.
        /// Emits an event with caller's identity.
        #[weight = 800_000_000]
        pub fn get_my_did(origin) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            let did = Context::current_identity_or::<Self>(&sender)?;

            Self::deposit_event(RawEvent::DidStatus(did, sender));
            Ok(())
        }

        // TODO: Remove before mainnet launch.
        /// Emits an event with caller's identity and CDD status.
        #[weight = 800_000_000]
        pub fn get_cdd_of(_origin, of: T::AccountId) -> DispatchResult {
            let did_opt = Self::get_identity(&of);
            let has_cdd = did_opt.iter()
                .copied()
                .map(Self::has_valid_cdd)
                .next()
                .unwrap_or_default();

            Self::deposit_event(RawEvent::CddStatus(did_opt, of, has_cdd));
            Ok(())
        }

        // Manage generic authorizations
        /// Adds an authorization.
        #[weight = 900_000_000]
        pub fn add_authorization(
            origin,
            target: Signatory<T::AccountId>,
            authorization_data: AuthorizationData<T::AccountId>,
            expiry: Option<T::Moment>
        ) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            let from_did = Context::current_identity_or::<Self>(&sender)?;
            Self::add_auth(from_did, target, authorization_data, expiry);
            Ok(())
        }

        // Manage generic authorizations
        /// Adds an array of authorizations.
        ///
        /// # Weight
        /// `900_000_000 + 50_000 * auths.len()`
        #[weight =(
            900_000_000 + 500_000 * u64::try_from(auths.len()).unwrap_or_default(),
            DispatchClass::Normal,
            Pays::Yes
        )]
        pub fn batch_add_authorization(
            origin,
            // Vec<(target_did, auth_data, expiry)>
            auths: Vec<(Signatory<T::AccountId>, AuthorizationData<T::AccountId>, Option<T::Moment>)>
        ) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            let from_did = Context::current_identity_or::<Self>(&sender)?;
            for auth in auths {
                Self::add_auth(from_did, auth.0, auth.1, auth.2);
            }
            Ok(())
        }

        /// Removes an authorization.
        #[weight = 900_000_000]
        pub fn remove_authorization(
            origin,
            target: Signatory<T::AccountId>,
            auth_id: u64
        ) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            let from_did = Context::current_identity_or::<Self>(&sender)?;

            let auth = Self::ensure_authorization(&target, auth_id)?;
            let revoked = auth.authorized_by == from_did;
            ensure!(
                revoked || target.eq_either(&from_did, &sender),
                Error::<T>::Unauthorized
            );
            Self::unsafe_remove_auth(&target, auth_id, &auth.authorized_by, revoked);

            Ok(())
        }

        /// Removes an array of authorizations.
        ///
        /// # Weight
        /// `900_000_000 + 1_000_000 * auths.len()`
        #[weight =(
            900_000_000 + 1_000_000 * u64::try_from(auth_identifiers.len()).unwrap_or_default(),
            DispatchClass::Normal,
            Pays::Yes
        )]
        pub fn batch_remove_authorization(
            origin,
            auth_identifiers: Vec<AuthIdentifier<T::AccountId>>
        ) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            let from_did = Context::current_identity_or::<Self>(&sender)?;
            let mut auths = Vec::with_capacity(auth_identifiers.len());
            let mut revoked = Vec::with_capacity(auth_identifiers.len());
            for (i, AuthIdentifier(ref sig, ref auth_id)) in auth_identifiers.iter().enumerate() {
                auths.push(Self::ensure_authorization(sig, *auth_id)?);
                revoked.push(auths[i].authorized_by == from_did);
                ensure!(
                    revoked[i] || sig.eq_either(&from_did, &sender),
                    Error::<T>::Unauthorized
                );
            }

            for ((auth_id, auth), revoked) in auth_identifiers.into_iter().zip(auths).zip(revoked) {
                Self::unsafe_remove_auth(&auth_id.0, auth_id.1, &auth.authorized_by, revoked);

            }

            Ok(())
        }

        /// Accepts an authorization.
        #[weight = 2_000_000_000]
        pub fn accept_authorization(
            origin,
            auth_id: u64
        ) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            let signer_key = Signatory::Account(sender.clone());
            let signer_did = Context::current_identity_or::<Self>(&sender)
                .map_or_else(
                    |_error| signer_key.clone(),
                    Signatory::from);

            // Get auth by key or by id.
            let (auth, signer) = Self::maybe_authorization(&signer_did, auth_id)
                .map(|a| (a, signer_did))
                .or_else(|| Self::maybe_authorization(&signer_key, auth_id).map(|a| (a, signer_key)))
                .ok_or_else(||Error::<T>::AuthorizationDoesNotExist)?;

            match signer {
                Signatory::Identity(did) => {
                    match auth.authorization_data {
                        AuthorizationData::TransferTicker(_) =>
                            T::AcceptTransferTarget::accept_ticker_transfer(did, auth_id),
                        AuthorizationData::TransferPrimaryIssuanceAgent(_) =>
                            T::AcceptTransferTarget::accept_primary_issuance_agent_transfer(did, auth_id),
                        AuthorizationData::TransferAssetOwnership(_) =>
                            T::AcceptTransferTarget::accept_asset_ownership_transfer(did, auth_id),
                        AuthorizationData::AddMultiSigSigner(_) =>
                            T::MultiSig::accept_multisig_signer(Signatory::from(did), auth_id),
                        AuthorizationData::JoinIdentity(_) =>
                            Self::join_identity(Signatory::from(did), auth_id),
                        AuthorizationData::PortfolioCustody(..) =>
                            T::Portfolio::accept_portfolio_custody(did, auth_id),
                        AuthorizationData::RotatePrimaryKey(..)
                        | AuthorizationData::AttestPrimaryKeyRotation(..)
                        | AuthorizationData::Custom(..)
                        | AuthorizationData::NoData =>
                            Err(Error::<T>::UnknownAuthorization.into())
                    }
                },
                Signatory::Account(key) => {
                    match auth.authorization_data {
                        AuthorizationData::AddMultiSigSigner(_) =>
                            T::MultiSig::accept_multisig_signer(Signatory::Account(key), auth_id),
                        AuthorizationData::RotatePrimaryKey(_identityid) =>
                            Self::accept_primary_key_rotation(key , auth_id, None),
                        AuthorizationData::JoinIdentity(_) =>
                            Self::join_identity(Signatory::Account(key), auth_id),
                        AuthorizationData::TransferTicker(..)
                        | AuthorizationData::TransferPrimaryIssuanceAgent(..)
                        | AuthorizationData::TransferAssetOwnership(..)
                        | AuthorizationData::AttestPrimaryKeyRotation(..)
                        | AuthorizationData::PortfolioCustody(..)
                        | AuthorizationData::Custom(..)
                        | AuthorizationData::NoData =>
                            Err(Error::<T>::UnknownAuthorization.into())
                    }
                }
            }
        }

        /// Accepts an array of authorizations.
        /// NB: Even if an auth is invalid (due to any reason), this batch function does NOT return an error.
        /// It will just skip that particular authorization.
        ///
        /// # Weight
        /// `2_000_000_000 + 5_000_000 * auth_ids.len()`
        #[weight =(
            2_000_000_000 + 5_000_000 * u64::try_from(auth_ids.len()).unwrap_or_default(),
            DispatchClass::Normal,
            Pays::Yes
        )]
        pub fn batch_accept_authorization(
            origin,
            auth_ids: Vec<u64>
        ) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            let signer = Context::current_identity_or::<Self>(&sender)
                .map_or_else(
                    |_error| Signatory::Account(sender),
                    Signatory::from);

            match &signer {
                Signatory::Identity(did) => {
                    for auth in auth_ids.into_iter().filter_map(|id| Self::maybe_authorization(&signer, id)) {
                            // NB: Result is not handled, invalid auths are just ignored to let the batch function continue.
                        let _ = match auth.authorization_data {
                            AuthorizationData::TransferTicker(_) =>
                                T::AcceptTransferTarget::accept_ticker_transfer(*did, auth.auth_id),
                            AuthorizationData::TransferAssetOwnership(_) =>
                                T::AcceptTransferTarget::accept_asset_ownership_transfer(*did, auth.auth_id),
                            AuthorizationData::AddMultiSigSigner(_) =>
                                T::MultiSig::accept_multisig_signer(Signatory::from(*did), auth.auth_id),
                            AuthorizationData::JoinIdentity(_) =>
                                Self::join_identity(Signatory::from(*did), auth.auth_id),
                            _ => Err(Error::<T>::UnknownAuthorization.into())
                        };
                    }
                },
                Signatory::Account(key) => {
                    for auth in auth_ids.into_iter().filter_map(|id| Self::maybe_authorization(&signer, id)) {
                        // NB: Result is not handled, invalid auths are just ignored to let the batch function continue.
                        let _ = match auth.authorization_data {
                            AuthorizationData::AddMultiSigSigner(_) =>
                                T::MultiSig::accept_multisig_signer(
                                    Signatory::Account(key.clone()),
                                    auth.auth_id
                                ),
                            AuthorizationData::RotatePrimaryKey(_identityid) =>
                                Self::accept_primary_key_rotation(key.clone(), auth.auth_id, None),
                            AuthorizationData::JoinIdentity(_) =>
                                Self::join_identity(Signatory::Account(key.clone()), auth.auth_id),
                            _ => Err(Error::<T>::UnknownAuthorization.into())
                        };
                    }
                }
            }

            Ok(())
        }

        /// It adds secondary keys to target identity `id`.
        /// Keys are directly added to identity because each of them has an authorization.
        ///
        /// Arguments:
        ///     - `origin` Primary key of `id` identity.
        ///     - `id` Identity where new secondary keys will be added.
        ///     - `additional_keys` New secondary items (and their authorization data) to add to target
        ///     identity.
        ///
        /// Failure
        ///     - It can only called by primary key owner.
        ///     - Keys should be able to linked to any identity.
        ///
        /// # Weight
        /// `2_000_000_000 + 2_000_000 * auths.len()`
        #[weight = (
            2_000_000_000 + 2_000_000 * u64::try_from(additional_keys.len()).unwrap_or_default(),
            DispatchClass::Normal,
            Pays::Yes
        )]
        pub fn batch_add_secondary_key_with_authorization(
            origin,
            additional_keys: Vec<SecondaryKeyWithAuth<T::AccountId>>,
            expires_at: T::Moment
        ) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            let id = Context::current_identity_or::<Self>(&sender)?;
            let _grants_checked = Self::grant_check_only_primary_key(&sender, id)?;

            // 0. Check expiration
            let now = <pallet_timestamp::Module<T>>::get();
            ensure!(now < expires_at, Error::<T>::AuthorizationExpired);
            let authorization = TargetIdAuthorization {
                target_id: id,
                nonce: Self::offchain_authorization_nonce(id),
                expires_at
            };
            let auth_encoded = authorization.encode();

            // 1. Verify signatures.
            for si_with_auth in additional_keys.iter() {
                let si = &si_with_auth.secondary_key;

                // Get account_id from signer
                let account_id_found = match si.signer.clone() {
                    Signatory::Account(key) => Some(key),
                    Signatory::Identity(id) => Self::identity_record_of(id).map(|r| r.primary_key),
                };

                if let Some(account_id) = account_id_found {
                    if let Signatory::Account(key) = &si.signer {
                        // 1.1. Constraint 1-to-1 account to DID
                        ensure!(
                            Self::can_key_be_linked_to_did(key),
                            Error::<T>::AlreadyLinked
                        );
                    }
                    // 1.2. Offchain authorization is not revoked explicitly.
                    let si_signer_authorization = &(si.signer.clone(), authorization.clone());
                    ensure!(
                        !Self::is_offchain_authorization_revoked(si_signer_authorization),
                        Error::<T>::AuthorizationHasBeenRevoked
                    );
                    // 1.3. Verify the signature.
                    let signature = AnySignature::from(Signature::from_h512(si_with_auth.auth_signature));
                    let signer: <<AnySignature as Verify>::Signer as IdentifyAccount>::AccountId =
                        Decode::decode(&mut &account_id.encode()[..]).map_err(|_| {
                            Error::<T>::CannotDecodeSignerAccountId
                        })?;
                    ensure!(
                        signature.verify(auth_encoded.as_slice(), &signer),
                        Error::<T>::InvalidAuthorizationSignature
                    );
                } else {
                    return Err(Error::<T>::InvalidAccountKey.into());
                }
            }
            // 1.999. Charge the fee.
            T::ProtocolFee::batch_charge_fee(
                ProtocolOp::IdentityAddSecondaryKeysWithAuthorization,
                additional_keys.len()
            )?;
            // 2.1. Link keys to identity
            let additional_keys_si = additional_keys.into_iter()
                .map( |si_with_auth| si_with_auth.secondary_key)
                .collect::<Vec<_>>();

            additional_keys_si.iter().for_each( |si| {
                if let Signatory::Account(ref key) = si.signer {
                    Self::link_key_to_did(key, id);
                }
            });
            // 2.2. Update that identity information and its offchain authorization nonce.
            <DidRecords<T>>::mutate(id, |record| {
                (*record).add_secondary_keys(&additional_keys_si[..]);
            });
            <OffChainAuthorizationNonce>::mutate(id, |offchain_nonce| {
                *offchain_nonce = authorization.nonce + 1;
            });

            Self::deposit_event(RawEvent::SecondaryKeysAdded(id, additional_keys_si));

            Ok(())
        }

        /// It revokes the `auth` off-chain authorization of `signer`. It only takes effect if
        /// the authorized transaction is not yet executed.
        #[weight = 850_000_000]
        pub fn revoke_offchain_authorization(
            origin,
            signer: Signatory<T::AccountId>,
            auth: TargetIdAuthorization<T::Moment>
        ) -> DispatchResult {
            let sender = ensure_signed(origin)?;

            match &signer {
                Signatory::Account(key) => {
                    ensure!(&sender == key, Error::<T>::KeyNotAllowed);
                }
                Signatory::Identity(id) => {
                    ensure!(Self::is_primary_key(*id, &sender), Error::<T>::NotPrimaryKey);
                }
            }

            Self::deposit_event(
                RawEvent::OffChainAuthorizationRevoked(
                    auth.target_id,
                    signer.clone()
                )
            );
            <RevokeOffChainAuthorization<T>>::insert((signer, auth), true);
            Ok(())
        }
    }
}

decl_error! {
    pub enum Error for Module<T: Trait> {
        /// One secondary key can only belong to one DID
        AlreadyLinked,
        /// Missing current identity on the transaction
        MissingCurrentIdentity,
        /// Sender is not part of did's secondary keys
        InvalidSender,
        /// No did linked to the user
        NoDIDFound,
        /// Signatory is not pre authorized by the identity
        Unauthorized,
        /// Given authorization is not pre-known
        UnknownAuthorization,
        /// Account Id cannot be extracted from signer
        InvalidAccountKey,
        /// Only CDD service providers are allowed.
        UnAuthorizedCddProvider,
        /// An invalid authorization from the owner.
        InvalidAuthorizationFromOwner,
        /// An invalid authorization from the CDD provider.
        InvalidAuthorizationFromCddProvider,
        /// The authorization to change the key was not from the owner of the primary key.
        KeyChangeUnauthorized,
        /// Attestation was not by a CDD service provider.
        NotCddProviderAttestation,
        /// Authorizations are not for the same DID.
        AuthorizationsNotForSameDids,
        /// The DID must already exist.
        DidMustAlreadyExist,
        /// The Claim issuer DID must already exist.
        ClaimIssuerDidMustAlreadyExist,
        /// Sender must hold a claim issuer's secondary key.
        SenderMustHoldClaimIssuerKey,
        /// Current identity cannot be forwarded, it is not a secondary key of target identity.
        CurrentIdentityCannotBeForwarded,
        /// The authorization does not exist.
        AuthorizationDoesNotExist,
        /// The offchain authorization has expired.
        AuthorizationExpired,
        /// The primary key is already linked to an identity.
        PrimaryKeyAlreadyLinked,
        /// The target DID has no valid CDD.
        TargetHasNoCdd,
        /// Authorization has been explicitly revoked.
        AuthorizationHasBeenRevoked,
        /// An invalid authorization signature.
        InvalidAuthorizationSignature,
        /// This key is not allowed to execute a given operation.
        KeyNotAllowed,
        /// Only the primary key is allowed to revoke an Identity Signatory off-chain authorization.
        NotPrimaryKey,
        /// The DID does not exist.
        DidDoesNotExist,
        /// The DID already exists.
        DidAlreadyExists,
        /// The secondary keys contain the primary key.
        SecondaryKeysContainPrimaryKey,
        /// Couldn't charge fee for the transaction.
        FailedToChargeFee,
        /// Signer is not a secondary key of the provided identity
        NotASigner,
        /// Cannot convert a `T::AccountId` to `AnySignature::Signer::AccountId`.
        CannotDecodeSignerAccountId,
        /// Multisig can not be unlinked from an identity while it still holds POLYX
        MultiSigHasBalance,
        /// Confidential Scope claims can be added by an Identity to it-self.
        ConfidentialScopeClaimNotAllowed
    }
}

impl<T: Trait> Module<T> {
    /// Only used by `create_asset` since `AssetDidRegistered` is defined here instead of there.
    pub fn commit_token_did(did: IdentityId, ticker: Ticker) {
        <DidRecords<T>>::insert(did, DidRecord::default());
        Self::deposit_event(RawEvent::AssetDidRegistered(did, ticker));
    }

    pub fn ensure_no_id_record(id: IdentityId) -> DispatchResult {
        ensure!(!Self::is_identity_exists(&id), Error::<T>::DidAlreadyExists);
        Ok(())
    }

    /// Returns `Err(DidDoesNotExist)` unless `id` has an associated record.
    fn ensure_id_record_exists(id: IdentityId) -> DispatchResult {
        ensure!(Self::is_identity_exists(&id), Error::<T>::DidDoesNotExist);
        Ok(())
    }

    /// Accepts an auth to join an identity as a signer
    pub fn join_identity(signer: Signatory<T::AccountId>, auth_id: u64) -> DispatchResult {
        ensure!(
            <Authorizations<T>>::contains_key(&signer, auth_id),
            AuthorizationError::Invalid
        );

        let auth = <Authorizations<T>>::get(&signer, auth_id);

        let permissions = match auth.authorization_data {
            AuthorizationData::JoinIdentity(permissions) => Ok(permissions),
            _ => Err(AuthorizationError::Invalid),
        }?;

        // Not really needed unless we allow identities to be deleted.
        Self::ensure_id_record_exists(auth.authorized_by)?;

        Self::consume_auth(auth.authorized_by, signer.clone(), auth_id)?;

        Self::unsafe_join_identity(auth.authorized_by, permissions, signer)
    }

    /// Joins an identity as signer
    pub fn unsafe_join_identity(
        target_did: IdentityId,
        permissions: Vec<Permission>,
        signer: Signatory<T::AccountId>,
    ) -> DispatchResult {
        T::ProtocolFee::charge_fee(ProtocolOp::IdentityAddSecondaryKeysWithAuthorization)?;
        if let Signatory::Account(key) = &signer {
            ensure!(
                Self::can_key_be_linked_to_did(key),
                Error::<T>::AlreadyLinked
            );
            Self::link_key_to_did(key, target_did);
        }

        // create the SecondaryKey
        let sg_item = SecondaryKey::new(signer, permissions);

        <DidRecords<T>>::mutate(target_did, |identity| {
            identity.add_secondary_keys(&[sg_item.clone()]);
        });

        Self::deposit_event(RawEvent::SecondaryKeysAdded(target_did, [sg_item].to_vec()));

        Ok(())
    }

    /// Adds an authorization.
    pub fn add_auth(
        from: IdentityId,
        target: Signatory<T::AccountId>,
        authorization_data: AuthorizationData<T::AccountId>,
        expiry: Option<T::Moment>,
    ) -> u64 {
        let new_nonce = Self::multi_purpose_nonce() + 1u64;
        <MultiPurposeNonce>::put(&new_nonce);

        let auth = Authorization {
            authorization_data: authorization_data.clone(),
            authorized_by: from,
            expiry,
            auth_id: new_nonce,
        };

        <Authorizations<T>>::insert(target.clone(), new_nonce, auth);
        <AuthorizationsGiven<T>>::insert(from, new_nonce, target.clone());

        // This event is split in order to help the event harvesters.
        Self::deposit_event(RawEvent::AuthorizationAdded(
            from,
            target.as_identity().cloned(),
            target.as_account().cloned(),
            new_nonce,
            authorization_data,
            expiry,
        ));

        new_nonce
    }

    /// Removes any authorization. No questions asked.
    /// NB: Please do all the required checks before calling this function.
    pub fn unsafe_remove_auth(
        target: &Signatory<T::AccountId>,
        auth_id: u64,
        authorizer: &IdentityId,
        revoked: bool,
    ) {
        <Authorizations<T>>::remove(target, auth_id);
        <AuthorizationsGiven<T>>::remove(authorizer, auth_id);
        let id = target.as_identity().cloned();
        let acc = target.as_account().cloned();
        let event = if revoked {
            RawEvent::AuthorizationRevoked
        } else {
            RawEvent::AuthorizationRejected
        };
        Self::deposit_event(event(id, acc, auth_id))
    }

    /// Consumes an authorization.
    /// Checks if the auth has not expired and the caller is authorized to consume this auth.
    pub fn consume_auth(
        from: IdentityId,
        target: Signatory<T::AccountId>,
        auth_id: u64,
    ) -> DispatchResult {
        ensure!(
            Self::has_authorization(&target, auth_id),
            AuthorizationError::Invalid
        );

        let auth = <Authorizations<T>>::get(&target, auth_id);
        ensure!(auth.authorized_by == from, AuthorizationError::Unauthorized);
        if let Some(expiry) = auth.expiry {
            let now = <pallet_timestamp::Module<T>>::get();
            ensure!(expiry > now, AuthorizationError::Expired);
        }

        <Authorizations<T>>::remove(&target, auth_id);
        <AuthorizationsGiven<T>>::remove(auth.authorized_by, auth_id);

        Self::deposit_event(RawEvent::AuthorizationConsumed(
            target.as_identity().cloned(),
            target.as_account().cloned(),
            auth_id,
        ));
        Ok(())
    }

    fn ensure_authorization(
        target: &Signatory<T::AccountId>,
        auth_id: u64,
    ) -> Result<Authorization<T::AccountId, T::Moment>, Error<T>> {
        Self::maybe_authorization(target, auth_id)
            .ok_or_else(|| Error::<T>::AuthorizationDoesNotExist)
    }

    fn maybe_authorization(
        target: &Signatory<T::AccountId>,
        auth_id: u64,
    ) -> Option<Authorization<T::AccountId, T::Moment>> {
        if Self::has_authorization(target, auth_id) {
            Some(Self::get_authorization(target, auth_id))
        } else {
            None
        }
    }

    /// Returns `true` if `target` has the given `auth_id`.
    fn has_authorization(target: &Signatory<T::AccountId>, auth_id: u64) -> bool {
        <Authorizations<T>>::contains_key(target, auth_id)
    }

    /// Fetches a particular authorization.
    pub fn get_authorization(
        target: &Signatory<T::AccountId>,
        auth_id: u64,
    ) -> Authorization<T::AccountId, T::Moment> {
        <Authorizations<T>>::get(target, auth_id)
    }

    /// Accepts a primary key rotation.
    fn accept_primary_key_rotation(
        sender: T::AccountId,
        rotation_auth_id: u64,
        optional_cdd_auth_id: Option<u64>,
    ) -> DispatchResult {
        let signer = Signatory::Account(sender.clone());
        // ensure authorization is present
        ensure!(
            Self::has_authorization(&signer, rotation_auth_id),
            Error::<T>::InvalidAuthorizationFromOwner
        );

        // Accept authorization from the owner
        let rotation_auth = Self::get_authorization(&signer, rotation_auth_id);

        if let AuthorizationData::RotatePrimaryKey(rotation_for_did) =
            rotation_auth.authorization_data
        {
            // consume owner's authorization
            Self::consume_auth(rotation_for_did, signer, rotation_auth_id)?;
            Self::unsafe_primary_key_rotation(sender, rotation_for_did, optional_cdd_auth_id)
        } else {
            Err(Error::<T>::UnknownAuthorization.into())
        }
    }

    /// Processes primary key rotation.
    pub fn unsafe_primary_key_rotation(
        sender: T::AccountId,
        rotation_for_did: IdentityId,
        optional_cdd_auth_id: Option<u64>,
    ) -> DispatchResult {
        // Aceept authorization from CDD service provider
        if Self::cdd_auth_for_primary_key_rotation() {
            let cdd_auth_id = optional_cdd_auth_id
                .ok_or_else(|| Error::<T>::InvalidAuthorizationFromCddProvider)?;

            let signer = Signatory::Account(sender.clone());
            ensure!(
                Self::has_authorization(&signer, cdd_auth_id),
                Error::<T>::InvalidAuthorizationFromCddProvider
            );
            let cdd_auth = <Authorizations<T>>::get(&signer, cdd_auth_id);

            match cdd_auth.authorization_data {
                AuthorizationData::AttestPrimaryKeyRotation(ref attestation_for_did) => {
                    // Attestor must be a CDD service provider
                    ensure!(
                        T::CddServiceProviders::is_member(&cdd_auth.authorized_by),
                        Error::<T>::NotCddProviderAttestation
                    );

                    // Make sure authorizations are for the same DID
                    ensure!(
                        rotation_for_did == *attestation_for_did,
                        Error::<T>::AuthorizationsNotForSameDids
                    );

                    // consume CDD service provider's authorization
                    // here we pass the known authorising identity to consume_auth, rather than the expected authorising identity
                    // as we've already checked the validity above
                    Self::consume_auth(cdd_auth.authorized_by, signer, cdd_auth_id)?;
                }
                _ => return Err(Error::<T>::UnknownAuthorization.into()),
            }
        }

        // Replace primary key of the owner that initiated key rotation
        let old_primary_key = Self::did_records(&rotation_for_did).primary_key;
        <DidRecords<T>>::mutate(&rotation_for_did, |record| {
            Self::unlink_key_from_did(&record.primary_key, rotation_for_did);
            record.primary_key = sender.clone();
            Self::link_key_to_did(&sender, rotation_for_did);
        });

        Self::deposit_event(RawEvent::PrimaryKeyUpdated(
            rotation_for_did,
            old_primary_key,
            sender,
        ));
        Ok(())
    }

    /// Updates permissions of secondary items.
    /// Private and not sanitized function. It is designed to be used internally by
    /// others sanitezed functions.
    fn update_secondary_key_permissions(
        target_did: IdentityId,
        signer: &Signatory<T::AccountId>,
        mut permissions: Vec<Permission>,
    ) -> DispatchResult {
        // Remove duplicates.
        permissions.sort();
        permissions.dedup();

        let mut new_s_item: Option<SecondaryKey<T::AccountId>> = None;

        <DidRecords<T>>::mutate(target_did, |record| {
            if let Some(mut secondary_key) = (*record)
                .secondary_keys
                .iter()
                .find(|si| si.signer == *signer)
                .cloned()
            {
                swap(&mut secondary_key.permissions, &mut permissions);
                (*record).secondary_keys.retain(|si| si.signer != *signer);
                (*record).secondary_keys.push(secondary_key.clone());
                new_s_item = Some(secondary_key);
            }
        });

        if let Some(s) = new_s_item {
            Self::deposit_event(RawEvent::SecondaryPermissionsUpdated(
                target_did,
                s,
                permissions,
            ));
        }
        Ok(())
    }

    /// It checks if `key` is a secondary key of `did` identity.
    /// # IMPORTANT
    /// If secondary keys are frozen this function always returns false.
    /// Primary key cannot be frozen.
    pub fn is_signer_authorized(did: IdentityId, signer: &Signatory<T::AccountId>) -> bool {
        let record = <DidRecords<T>>::get(did);

        // Check primary id or key
        match signer {
            Signatory::Account(ref signer_key) if record.primary_key == *signer_key => true,
            Signatory::Identity(ref signer_id) if did == *signer_id => true,
            _ => {
                // Check secondary items if DID is not frozen.
                !Self::is_did_frozen(did)
                    && record.secondary_keys.iter().any(|si| si.signer == *signer)
            }
        }
    }

    /// It checks if `key` is a secondary key of `did` identity.
    pub fn is_signer(did: IdentityId, signer: &Signatory<T::AccountId>) -> bool {
        let record = <DidRecords<T>>::get(did);
        record.secondary_keys.iter().any(|si| si.signer == *signer)
    }

    /// Checks if signer has correct permissions.
    fn is_signer_authorized_with_permissions(
        did: IdentityId,
        signer: &Signatory<T::AccountId>,
        permissions: Vec<Permission>,
    ) -> bool {
        let record = <DidRecords<T>>::get(did);

        match signer {
            Signatory::Account(ref signer_key) if record.primary_key == *signer_key => true,
            Signatory::Identity(ref signer_id) if did == *signer_id => true,
            _ => {
                if !Self::is_did_frozen(did) {
                    if let Some(secondary_key) = record
                        .secondary_keys
                        .iter()
                        .find(|&si| &si.signer == signer)
                    {
                        // It retruns true if all requested permission are in this secondary item.
                        return permissions.iter().all(|required_permission| {
                            secondary_key.has_permission(*required_permission)
                        });
                    }
                }
                // Signatory is not part of secondary items of `did`, or
                // Did is frozen.
                false
            }
        }
    }

    /// Use `did` as reference.
    pub fn is_primary_key(did: IdentityId, key: &T::AccountId) -> bool {
        key == &<DidRecords<T>>::get(did).primary_key
    }

    /// It returns true if `id_claim` is not expired at `moment`.
    #[inline]
    fn is_identity_claim_not_expired_at(id_claim: &IdentityClaim, moment: T::Moment) -> bool {
        if let Some(expiry) = id_claim.expiry {
            expiry > moment.saturated_into::<u64>()
        } else {
            true
        }
    }

    /// It fetches an specific `claim_type` claim type for target identity `id`, which was issued
    /// by `issuer`.
    /// It only returns non-expired claims.
    pub fn fetch_claim(
        id: IdentityId,
        claim_type: ClaimType,
        issuer: IdentityId,
        scope: Option<Scope>,
    ) -> Option<IdentityClaim> {
        let now = <pallet_timestamp::Module<T>>::get();

        Self::fetch_base_claim_with_issuer(id, claim_type, issuer, scope)
            .into_iter()
            .find(|c| Self::is_identity_claim_not_expired_at(c, now))
    }

    /// See `Self::fetch_cdd`.
    #[inline]
    pub fn has_valid_cdd(claim_for: IdentityId) -> bool {
        let trusted_cdd_providers = T::CddServiceProviders::get_members();
        // It will never happen in production but helpful during testing.
        // TODO: Remove this condition
        if trusted_cdd_providers.is_empty() {
            return true;
        }

        Self::fetch_cdd(claim_for, T::Moment::zero()).is_some()
    }

    /// It returns the CDD identity which issued the current valid CDD claim for `claim_for`
    /// identity.
    /// # Parameters
    /// * `leeway` : This leeway is added to now() before check if claim is expired.
    ///
    /// # Safety
    ///
    /// No state change is allowed in this function because this function is used within the RPC
    /// calls.
    pub fn fetch_cdd(claim_for: IdentityId, leeway: T::Moment) -> Option<IdentityId> {
        Self::base_fetch_cdd(claim_for, leeway, None)
    }

    fn base_fetch_cdd(
        claim_for: IdentityId,
        leeway: T::Moment,
        filter_cdd_id: Option<CddId>,
    ) -> Option<IdentityId> {
        let exp_with_leeway = <pallet_timestamp::Module<T>>::get()
            .checked_add(&leeway)
            .unwrap_or_default();

        let active_cdds = T::CddServiceProviders::get_active_members();
        let inactive_not_expired_cdds = T::CddServiceProviders::get_inactive_members()
            .into_iter()
            .filter(|cdd| !T::CddServiceProviders::is_member_expired(cdd, exp_with_leeway))
            .collect::<Vec<_>>();

        Self::fetch_base_claims(claim_for, ClaimType::CustomerDueDiligence)
            .filter(|id_claim| {
                if let Some(cdd_id) = &filter_cdd_id {
                    if let Claim::CustomerDueDiligence(claim_cdd_id) = &id_claim.claim {
                        if claim_cdd_id != cdd_id {
                            return false;
                        }
                    }
                }

                Self::is_identity_cdd_claim_valid(
                    id_claim,
                    exp_with_leeway,
                    &active_cdds,
                    &inactive_not_expired_cdds,
                )
            })
            .map(|id_claim| id_claim.claim_issuer)
            .next()
    }

    /// A CDD claims is considered valid if:
    /// * Claim is not expired at `exp_with_leeway` moment.
    /// * Its issuer is valid, that means:
    ///   * Issuer is an active CDD provider, or
    ///   * Issuer is an inactive CDD provider but claim was updated/created before that it was
    ///   deactivated.
    fn is_identity_cdd_claim_valid(
        id_claim: &IdentityClaim,
        exp_with_leeway: T::Moment,
        active_cdds: &[IdentityId],
        inactive_not_expired_cdds: &[InactiveMember<T::Moment>],
    ) -> bool {
        Self::is_identity_claim_not_expired_at(id_claim, exp_with_leeway)
            && (active_cdds.contains(&id_claim.claim_issuer)
                || inactive_not_expired_cdds
                    .iter()
                    .filter(|cdd| cdd.id == id_claim.claim_issuer)
                    .any(|cdd| {
                        id_claim.last_update_date < cdd.deactivated_at.saturated_into::<u64>()
                    }))
    }

    /// It iterates over all claims of type `claim_type` for target `id` identity.
    /// Please note that it could return expired claims.
    fn fetch_base_claims<'a>(
        target: IdentityId,
        claim_type: ClaimType,
    ) -> impl Iterator<Item = IdentityClaim> + 'a {
        let pk = Claim1stKey { target, claim_type };
        <Claims>::iter_prefix_values(pk)
    }

    /// It fetches an specific `claim_type` claim type for target identity `id`, which was issued
    /// by `issuer`.
    fn fetch_base_claim_with_issuer(
        target: IdentityId,
        claim_type: ClaimType,
        issuer: IdentityId,
        scope: Option<Scope>,
    ) -> Option<IdentityClaim> {
        let pk = Claim1stKey { target, claim_type };
        let sk = Claim2ndKey { issuer, scope };

        if <Claims>::contains_key(&pk, &sk) {
            Some(<Claims>::get(&pk, &sk))
        } else {
            None
        }
    }

    /// It checks that `sender` is the primary key of `did` Identifier and that
    /// did exists.
    /// # Return
    /// A result object containing the `DidRecord` of `did`.
    pub fn grant_check_only_primary_key(
        sender: &T::AccountId,
        did: IdentityId,
    ) -> sp_std::result::Result<DidRecord<T::AccountId>, DispatchError> {
        Self::ensure_id_record_exists(did)?;
        let record = <DidRecords<T>>::get(did);
        ensure!(*sender == record.primary_key, Error::<T>::KeyNotAllowed);
        Ok(record)
    }

    /// It checks if `key` is the primary key or secondary key of any IdentityId.
    /// Please note that _frozen secondary keys_ are not lined to the frozen identity temporary.
    ///
    /// # Return
    ///
    /// An Option object containing the `IdentityId` that belongs to the key.
    pub fn get_identity(key: &T::AccountId) -> Option<IdentityId> {
        match <KeyToIdentityIds<T>>::get(key)? {
            LinkedKeyInfo::Unique(id)
                if !Self::is_did_frozen(id) || Self::is_primary_key(id, key) =>
            {
                Some(id)
            }
            _ => None,
        }
    }

    /// It freezes/unfreezes the target `did` identity.
    ///
    /// # Errors
    /// Only primary key can freeze/unfreeze an identity.
    fn set_frozen_secondary_key_flags(origin: T::Origin, freeze: bool) -> DispatchResult {
        let sender = ensure_signed(origin)?;
        let did = Context::current_identity_or::<Self>(&sender)?;
        let _grants_checked = Self::grant_check_only_primary_key(&sender, did)?;

        let event = if freeze {
            <IsDidFrozen>::insert(&did, true);
            RawEvent::SecondaryKeysFrozen
        } else {
            <IsDidFrozen>::remove(&did);
            RawEvent::SecondaryKeysUnfrozen
        };
        Self::deposit_event(event(did));
        Ok(())
    }

    /// It checks that any external account can only be associated with at most one.
    /// Primary keys are considered as external accounts.
    pub fn can_key_be_linked_to_did(key: &T::AccountId) -> bool {
        if <KeyToIdentityIds<T>>::get(key).is_some() {
            false
        } else {
            !T::MultiSig::is_signer(key)
        }
    }

    /// It links `key` key to `did` identity as a `key_type` type.
    /// # Errors
    /// This function can be used if `can_key_be_linked_to_did` returns true. Otherwise, it will do
    /// nothing.
    fn link_key_to_did(key: &T::AccountId, did: IdentityId) {
        if <KeyToIdentityIds<T>>::get(key).is_none() {
            // `key` is not yet linked to any identity, so no constraints.
            let linked_key_info = LinkedKeyInfo::Unique(did);
            <KeyToIdentityIds<T>>::insert(key, linked_key_info);
        }
    }

    /// It unlinks the `key` key from `did`.
    /// If there is no more associated identities, its full entry is removed.
    fn unlink_key_from_did(key: &T::AccountId, did: IdentityId) {
        match <KeyToIdentityIds<T>>::get(key) {
            Some(LinkedKeyInfo::Unique(did_linked)) if did_linked == did => {
                <KeyToIdentityIds<T>>::remove(key);
            }
            Some(LinkedKeyInfo::Group(mut dids)) => {
                dids.retain(|ref_did| *ref_did != did);
                if dids.is_empty() {
                    <KeyToIdentityIds<T>>::remove(key);
                } else {
                    <KeyToIdentityIds<T>>::insert(key, LinkedKeyInfo::Group(dids));
                }
            }
            Some(LinkedKeyInfo::Unique(_)) | None => {}
        }
    }

    /// IMPORTANT: No state change is allowed in this function
    /// because this function is used within the RPC calls
    /// It is a helper function that can be used to get did for any asset
    pub fn get_token_did(ticker: &Ticker) -> StdResult<IdentityId, &'static str> {
        let mut buf = SECURITY_TOKEN.encode();
        buf.append(&mut ticker.encode());
        IdentityId::try_from(T::Hashing::hash(&buf[..]).as_ref())
    }

    /// Registers a did without adding a CDD claim for it.
    pub fn _register_did(
        sender: T::AccountId,
        secondary_keys: Vec<SecondaryKey<T::AccountId>>,
        protocol_fee_data: Option<ProtocolOp>,
    ) -> Result<IdentityId, DispatchError> {
        // Adding extrensic count to did nonce for some unpredictability
        // NB: this does not guarantee randomness
        let new_nonce =
            Self::multi_purpose_nonce() + u64::from(<system::Module<T>>::extrinsic_count()) + 7u64;
        // Even if this transaction fails, nonce should be increased for added unpredictability of dids
        <MultiPurposeNonce>::put(&new_nonce);

        // 1 Check constraints.
        // 1.1. Primary key is not linked to any identity.
        ensure!(
            Self::can_key_be_linked_to_did(&sender),
            Error::<T>::PrimaryKeyAlreadyLinked
        );
        // 1.2. Primary key is not part of secondary keys.
        ensure!(
            secondary_keys
                .iter()
                .find(|sk| sk.signer.as_account() == Some(&sender))
                .is_none(),
            Error::<T>::SecondaryKeysContainPrimaryKey
        );

        let block_hash = <system::Module<T>>::block_hash(<system::Module<T>>::block_number());
        let did = IdentityId::from_bytes(blake2_256(&(USER, block_hash, new_nonce).encode()));

        // 1.3. Make sure there's no pre-existing entry for the DID
        // This should never happen but just being defensive here
        Self::ensure_no_id_record(did)?;

        // 1.4. Secondary keys can be linked to the new identity.
        for s_item in &secondary_keys {
            if let Signatory::Account(ref key) = s_item.signer {
                ensure!(
                    Self::can_key_be_linked_to_did(key),
                    Error::<T>::AlreadyLinked
                );
            }
        }

        // 1.5. Charge the given fee.
        if let Some(op) = protocol_fee_data {
            T::ProtocolFee::charge_fee(op)?;
        }

        // 2. Apply changes to our extrinsic.
        // 2.1. Link primary key and add pre-authorized secondary keys.
        Self::link_key_to_did(&sender, did);
        let _auth_ids = secondary_keys
            .iter()
            .map(|s_item| {
                Self::add_auth(
                    did,
                    s_item.signer.clone(),
                    AuthorizationData::JoinIdentity(s_item.permissions.clone()),
                    None,
                )
            })
            .collect::<Vec<_>>();

        // 2.2. Create a new identity record.
        let record = DidRecord {
            primary_key: sender.clone(),
            ..Default::default()
        };
        <DidRecords<T>>::insert(&did, record);

        Self::deposit_event(RawEvent::DidCreated(did, sender, secondary_keys));
        Ok(did)
    }

    /// It adds a new claim without any previous security check.
    fn base_add_claim(
        target: IdentityId,
        claim: Claim,
        issuer: IdentityId,
        expiry: Option<T::Moment>,
    ) {
        let claim_type = claim.claim_type();
        let scope = claim.as_scope().cloned();
        let last_update_date = <pallet_timestamp::Module<T>>::get().saturated_into::<u64>();
        let issuance_date = Self::fetch_claim(target, claim_type, issuer, scope.clone())
            .map_or(last_update_date, |id_claim| id_claim.issuance_date);

        let expiry = expiry.into_iter().map(|m| m.saturated_into::<u64>()).next();
        let pk = Claim1stKey { target, claim_type };
        let sk = Claim2ndKey { issuer, scope };
        let id_claim = IdentityClaim {
            claim_issuer: issuer,
            issuance_date,
            last_update_date,
            expiry,
            claim,
        };

        <Claims>::insert(&pk, &sk, id_claim.clone());
        Self::deposit_event(RawEvent::ClaimAdded(target, id_claim));
    }

    /// It ensures that CDD claim issuer is a valid CDD provider before add the claim.
    ///
    /// # Errors
    /// - 'UnAuthorizedCddProvider' is returned if `issuer` is not a CDD provider.
    fn base_add_cdd_claim(
        target: IdentityId,
        claim: Claim,
        issuer: IdentityId,
        expiry: Option<T::Moment>,
    ) -> DispatchResult {
        Self::ensure_authorized_cdd_provider(issuer)?;

        Self::base_add_claim(target, claim, issuer, expiry);
        Ok(())
    }

    /// # Errors
    /// - 'ConfidentialScopeClaimNotAllowed` if :
    ///     - Sender is not the issuer. That claim can be only added by your-self.
    ///     - You are not the owner of that CDD_ID.
    ///
    fn base_add_confidential_scope_claim(
        target: IdentityId,
        claim: Claim,
        issuer: IdentityId,
        expiry: Option<T::Moment>,
        cdd_id: CddId,
    ) -> DispatchResult {
        // Only onwer of the identity can add that confidential claim.
        ensure!(
            issuer == target,
            Error::<T>::ConfidentialScopeClaimNotAllowed
        );

        // Verify the onwer of that CDD_ID.
        ensure!(
            Self::base_fetch_cdd(target, T::Moment::zero(), Some(cdd_id)).is_some(),
            Error::<T>::ConfidentialScopeClaimNotAllowed
        );

        Self::base_add_claim(target, claim, issuer, expiry);
        Ok(())
    }

    /// Does the identity given by `did` exist?
    pub fn is_identity_exists(did: &IdentityId) -> bool {
        <DidRecords<T>>::contains_key(did)
    }

    /// Returns the record corresponding to `id`, if it exists.
    fn identity_record_of(did: IdentityId) -> Option<DidRecord<T::AccountId>> {
        if Self::is_identity_exists(&did) {
            Some(<DidRecords<T>>::get(did))
        } else {
            None
        }
    }

    fn revoke_confidential_scope_claim(
        target: IdentityId,
        claim_type: ClaimType,
        issuer: IdentityId,
        scope: Option<Scope>,
    ) -> DispatchResult {
        ensure!(
            target == issuer,
            Error::<T>::ConfidentialScopeClaimNotAllowed
        );
        Self::base_revoke_claim(target, claim_type, issuer, scope);
        Ok(())
    }

    /// It removes a claim from `target` which was issued by `issuer` without any security check.
    fn base_revoke_claim(
        target: IdentityId,
        claim_type: ClaimType,
        issuer: IdentityId,
        scope: Option<Scope>,
    ) {
        let pk = Claim1stKey { target, claim_type };
        let sk = Claim2ndKey { scope, issuer };
        let claim = <Claims>::get(&pk, &sk);
        <Claims>::remove(&pk, &sk);
        Self::deposit_event(RawEvent::ClaimRevoked(target, claim));
    }

    /// Returns an auth id if it is present and not expired.
    pub fn get_non_expired_auth(
        target: &Signatory<T::AccountId>,
        auth_id: &u64,
    ) -> Option<Authorization<T::AccountId, T::Moment>> {
        Self::maybe_authorization(target, *auth_id).filter(|auth| {
            auth.expiry
                .filter(|&expiry| <pallet_timestamp::Module<T>>::get() > expiry)
                .is_none()
        })
    }

    /// Returns identity of a signatory
    pub fn get_identity_of_signatory(signer: &Signatory<T::AccountId>) -> Option<IdentityId> {
        match signer {
            Signatory::Account(key) => Self::get_identity(&key),
            Signatory::Identity(did) => Some(*did),
        }
    }

    fn leave_identity(signer: Signatory<T::AccountId>, did: IdentityId) -> DispatchResult {
        ensure!(Self::is_signer(did, &signer), Error::<T>::NotASigner);

        if let Signatory::Account(key) = &signer {
            if T::MultiSig::is_multisig(key) {
                ensure!(
                    T::Balances::total_balance(key).is_zero(),
                    Error::<T>::MultiSigHasBalance
                );
                // Unlink multisig signers from the identity.
                Self::unlink_multisig_signers_from_did(T::MultiSig::get_key_signers(key), did);
            }
            Self::unlink_key_from_did(key, did)
        }

        // Update secondary keys at Identity.
        <DidRecords<T>>::mutate(did, |record| {
            record.remove_secondary_keys(&[signer.clone()]);
        });

        Self::deposit_event(RawEvent::SignerLeft(did, signer));
        Ok(())
    }

    fn unlink_multisig_signers_from_did(signers: Vec<T::AccountId>, did: IdentityId) {
        for signer in signers {
            Self::unlink_key_from_did(&signer, did)
        }
    }
}

impl<T: Trait> Module<T> {
    /// RPC call to fetch some aggregate account data for fewer round trips.
    pub fn get_key_identity_data(acc: T::AccountId) -> Option<types::KeyIdentityData<IdentityId>> {
        let identity = Self::get_identity(&acc)?;
        let record = <DidRecords<T>>::get(identity);
        let permissions = if acc == record.primary_key {
            None
        } else {
            Some(record.secondary_keys.into_iter().find_map(|sk| {
                sk.signer.as_account().filter(|&a| a == &acc)?;
                Some(sk.permissions)
            })?)
        };
        Some(types::KeyIdentityData {
            identity,
            permissions,
        })
    }

    /// RPC call to know whether the given did has valid cdd claim or not
    pub fn is_identity_has_valid_cdd(
        target: IdentityId,
        leeway: Option<T::Moment>,
    ) -> Option<IdentityId> {
        Self::fetch_cdd(target, leeway.unwrap_or_default())
    }

    /// RPC call to query the given ticker did
    pub fn get_asset_did(ticker: Ticker) -> Result<IdentityId, &'static str> {
        Self::get_token_did(&ticker)
    }

    /// Retrieve DidRecords for `did`
    pub fn get_did_records(
        did: IdentityId,
    ) -> RpcDidRecords<T::AccountId, SecondaryKey<T::AccountId>> {
        if let Some(record) = Self::identity_record_of(did) {
            RpcDidRecords::Success {
                primary_key: record.primary_key,
                secondary_keys: record.secondary_keys,
            }
        } else {
            RpcDidRecords::IdNotFound
        }
    }

    /// Use to get the filtered authorization data for a given signatory
    /// - if auth_type is None then return authorizations data on the basis of the `allow_expired` boolean
    /// - if auth_type is Some(value) then return filtered authorizations on the value basis type in conjunction
    ///   with `allow_expired` boolean condition
    pub fn get_filtered_authorizations(
        signatory: Signatory<T::AccountId>,
        allow_expired: bool,
        auth_type: Option<AuthorizationType>,
    ) -> Vec<Authorization<T::AccountId, T::Moment>> {
        let now = <pallet_timestamp::Module<T>>::get();
        let auths = <Authorizations<T>>::iter_prefix_values(signatory)
            .filter(|auth| allow_expired || auth.expiry.filter(|&e| e < now).is_none());
        if let Some(auth_type) = auth_type {
            auths
                .filter(|auth| Self::get_type(auth.authorization_data.clone(), auth_type.clone()))
                .collect::<Vec<Authorization<T::AccountId, T::Moment>>>()
        } else {
            auths.collect::<Vec<Authorization<T::AccountId, T::Moment>>>()
        }
    }

    pub fn get_type(
        authorization_data: AuthorizationData<T::AccountId>,
        type_of_auth: AuthorizationType,
    ) -> bool {
        type_of_auth
            == match authorization_data {
                AuthorizationData::AttestPrimaryKeyRotation(..) => {
                    AuthorizationType::AttestPrimaryKeyRotation
                }
                AuthorizationData::RotatePrimaryKey(..) => AuthorizationType::RotatePrimaryKey,
                AuthorizationData::TransferTicker(..) => AuthorizationType::TransferTicker,
                AuthorizationData::TransferPrimaryIssuanceAgent(..) => {
                    AuthorizationType::TransferPrimaryIssuanceAgent
                }
                AuthorizationData::AddMultiSigSigner(..) => AuthorizationType::AddMultiSigSigner,
                AuthorizationData::TransferAssetOwnership(..) => {
                    AuthorizationType::TransferAssetOwnership
                }
                AuthorizationData::JoinIdentity(..) => AuthorizationType::JoinIdentity,
                AuthorizationData::PortfolioCustody(..) => AuthorizationType::PortfolioCustody,
                AuthorizationData::Custom(..) => AuthorizationType::Custom,
                AuthorizationData::NoData => AuthorizationType::NoData,
            }
    }

    pub fn get_did_status(dids: Vec<IdentityId>) -> Vec<DidStatus> {
        let mut result = Vec::with_capacity(dids.len());
        result.extend(dids.into_iter().map(|did| {
            // is DID exist in the ecosystem
            if !<DidRecords<T>>::contains_key(did) {
                DidStatus::Unknown
            }
            // DID exist but whether it has valid cdd or not
            else if Self::fetch_cdd(did, T::Moment::zero()).is_some() {
                DidStatus::CddVerified
            } else {
                DidStatus::Exists
            }
        }));
        result
    }

    /// Registers the systematic issuer with its DID.
    #[allow(dead_code)]
    fn register_systematic_id(issuer: SystematicIssuers)
    where
        <T as frame_system::Trait>::AccountId: core::fmt::Display,
    {
        let acc = issuer.as_module_id().into_account();
        let id = issuer.as_id();
        debug::info!(
            "Register Systematic id {} with account {} as {}",
            issuer,
            acc,
            id
        );

        Self::unsafe_register_id(acc, id);
    }

    /// Registers `primary_key` as `id` identity.
    #[allow(dead_code)]
    fn unsafe_register_id(primary_key: T::AccountId, id: IdentityId) {
        <Module<T>>::link_key_to_did(&primary_key, id);
        let record = DidRecord {
            primary_key: primary_key.clone(),
            ..Default::default()
        };
        <DidRecords<T>>::insert(&id, record);

        Self::deposit_event(RawEvent::DidCreated(id, primary_key, vec![]));
    }

    /// It returns the list of flatten identities of the given identity.
    /// It runs recursively over all secondary items.
    pub fn flatten_identities(id: IdentityId, max_depth: u8) -> Vec<IdentityId> {
        Self::identity_record_of(id)
            .map(|identity| {
                identity
                    .secondary_keys
                    .into_iter()
                    .flat_map(|si| match si.signer {
                        Signatory::Identity(sub_id) if max_depth > 0 => {
                            Self::flatten_identities(sub_id, max_depth - 1)
                        }
                        _ => vec![],
                    })
                    .chain(core::iter::once(id))
                    .collect::<Vec<_>>()
            })
            .unwrap_or_default()
    }

    /// Get the list of flatten keys fo the given identity.
    /// It runs recursively over all secondary items.
    pub fn flatten_keys(id: IdentityId, max_depth: u8) -> Vec<T::AccountId> {
        let sub_identities = Self::flatten_identities(id, max_depth);
        sub_identities
            .into_iter()
            .flat_map(|sub_id| {
                let identity = <DidRecords<T>>::get(sub_id);
                identity
                    .secondary_keys
                    .into_iter()
                    .filter_map(|si| match si.signer {
                        Signatory::Account(key) => Some(key),
                        _ => None,
                    })
                    .chain(core::iter::once(identity.primary_key))
            })
            .collect::<Vec<_>>()
    }

    /// Ensures that the did is an active CDD Provider.
    fn ensure_authorized_cdd_provider(did: IdentityId) -> DispatchResult {
        ensure!(
            T::CddServiceProviders::get_members().contains(&did),
            Error::<T>::UnAuthorizedCddProvider
        );
        Ok(())
    }

    /// Ensures that the caller is an active CDD provider and creates a new did for the target.
    /// This function returns the new did of the target.
    ///
    /// # Failure
    /// - `origin` has to be a active CDD provider. Inactive CDD providers cannot add new
    /// claims.
    /// - `target_account` (primary key of the new Identity) can be linked to just one and only
    /// one identity.
    /// - External secondary keys can be linked to just one identity.
    fn base_cdd_register_did(
        caller_did: IdentityId,
        target_account: T::AccountId,
        secondary_keys: Vec<SecondaryKey<T::AccountId>>,
    ) -> Result<IdentityId, DispatchError> {
        // Sender has to be part of CDDProviders
        Self::ensure_authorized_cdd_provider(caller_did)?;

        // Register Identity
        Self::_register_did(
            target_account,
            secondary_keys,
            Some(ProtocolOp::IdentityCddRegisterDid),
        )
    }
}

impl<T: Trait> IdentityTrait<T::AccountId> for Module<T> {
    /// Fetches identity of a key.
    fn get_identity(key: &T::AccountId) -> Option<IdentityId> {
        Self::get_identity(key)
    }

    /// Fetches the caller's identity from the context.
    fn current_identity() -> Option<IdentityId> {
        <CurrentDid>::get()
    }

    /// Sets the caller's identity in the context.
    fn set_current_identity(id: Option<IdentityId>) {
        if let Some(id) = id {
            <CurrentDid>::put(id);
        } else {
            <CurrentDid>::kill();
        }
    }

    /// Fetches the fee payer from the context.
    fn current_payer() -> Option<T::AccountId> {
        <CurrentPayer<T>>::get()
    }

    /// Sets the fee payer in the context.
    fn set_current_payer(payer: Option<T::AccountId>) {
        if let Some(payer) = payer {
            <CurrentPayer<T>>::put(payer);
        } else {
            <CurrentPayer<T>>::kill();
        }
    }

    /// Checks if the signer is authorized.
    fn is_signer_authorized(did: IdentityId, signer: &Signatory<T::AccountId>) -> bool {
        Self::is_signer_authorized(did, signer)
    }

    /// Checks if the keys is the primary key of the identity.
    fn is_primary_key(did: IdentityId, key: &T::AccountId) -> bool {
        Self::is_primary_key(did, key)
    }

    /// Checks if the signer is authorized and has certain permissions.
    fn is_signer_authorized_with_permissions(
        did: IdentityId,
        signer: &Signatory<T::AccountId>,
        permissions: Vec<Permission>,
    ) -> bool {
        Self::is_signer_authorized_with_permissions(did, signer, permissions)
    }

    /// Adds systematic CDD claims.
    fn add_systematic_cdd_claims(targets: &[IdentityId], issuer: SystematicIssuers) {
        for new_member in targets {
            let cdd_id = CddId::new(new_member.clone(), InvestorUid::from(new_member.as_ref()));
            let cdd_claim = Claim::CustomerDueDiligence(cdd_id);
            Self::base_add_claim(*new_member, cdd_claim, issuer.as_id(), None);
        }
    }

    /// Removes systematic CDD claims.
    fn revoke_systematic_cdd_claims(targets: &[IdentityId], issuer: SystematicIssuers) {
        targets.iter().for_each(|removed_member| {
            Self::base_revoke_claim(
                *removed_member,
                ClaimType::CustomerDueDiligence,
                issuer.as_id(),
                None,
            )
        });
    }

    /// Provides the DID status for the given DID
    fn has_valid_cdd(target_did: IdentityId) -> bool {
        Self::has_valid_cdd(target_did)
    }
}

impl<T: Trait> ChangeMembers<IdentityId> for Module<T> {
    /// Updates systematic CDDs of members of a group.
    fn change_members_sorted(
        incoming: &[IdentityId],
        outgoing: &[IdentityId],
        _new: &[IdentityId],
    ) {
        // Add/remove Systematic CDD claims for new/removed members.
        let issuer = SystematicIssuers::CDDProvider;
        Self::add_systematic_cdd_claims(incoming, issuer);
        Self::revoke_systematic_cdd_claims(outgoing, issuer);
    }
}

impl<T: Trait> InitializeMembers<IdentityId> for Module<T> {
    /// Initializes members of a group by adding systematic claims for them.
    fn initialize_members(members: &[IdentityId]) {
        Self::add_systematic_cdd_claims(members, SystematicIssuers::CDDProvider);
    }
}
