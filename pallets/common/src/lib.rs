// This file is part of the Polymesh distribution (https://github.com/PolymathNetwork/Polymesh).
// Copyright (c) 2020 Polymath

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, version 3.

// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

#![cfg_attr(not(feature = "std"), no_std)]
#![feature(bool_to_option)]

pub mod constants;

pub mod traits;
pub use traits::{
    asset, balances, base, compliance_manager, governance_group, group, identity, multisig, pip,
    portfolio, transaction_payment, CommonConfig, TestUtilsFn,
};
pub mod context;
pub use context::Context;

pub mod batch_dispatch_info;
pub use batch_dispatch_info::BatchDispatchInfo;

pub mod protocol_fee;
pub use protocol_fee::ChargeProtocolFee;

#[cfg(feature = "runtime-benchmarks")]
pub mod benchs;

use core::ops::Add;
use frame_support::codec::{Decode, Encode};
use polymesh_primitives::IdentityId;
#[cfg(feature = "std")]
use serde::{Deserialize, Serialize};
use sp_runtime::{DispatchResult, ModuleId};

/// It defines the valid issuers for Systematic Claims.
///
/// Systematic claims are claims generated by the system itself, and they are removed automatically
/// too.
///
/// There is just one Systematic claim at the moment, and It is generated by two issuers.
/// It is a CDD claim that is assigned to members of specific groups:
/// * Governance Committee: Each member of the committee has a CDD claim generated by
/// `SystematicIssuers::Committee` in order to allow it to operate independently of
/// claims generated by CDD trusted providers. Using that claim, GC members could operate even if
/// their CDD claim's issuer has been revoked.
/// * CDD Service Providers: Every CDD providers has a CDD claim generated by
/// `SystematicIssuers::CDDProvider` group, in order to avoid self-generated claim issue.
#[derive(Debug, Clone, Copy)]
pub enum SystematicIssuers {
    Committee,
    CDDProvider,
    Treasury,
    BlockRewardReserve,
    Settlement,
    ClassicMigration,
    FiatTickersReservation,
    Rewards,
}

impl core::fmt::Display for SystematicIssuers {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let value = match self {
            SystematicIssuers::Committee => "Governance Committee",
            SystematicIssuers::CDDProvider => "CDD Trusted Providers",
            SystematicIssuers::Treasury => "Treasury",
            SystematicIssuers::BlockRewardReserve => "Block Reward Reserve",
            SystematicIssuers::Settlement => "Settlement module",
            SystematicIssuers::ClassicMigration => "Polymath Classic Imports and Reservations",
            SystematicIssuers::FiatTickersReservation => "Fiat Ticker Reservation",
            SystematicIssuers::Rewards => "Reward module",
        };

        write!(f, "'{}'", value)
    }
}

pub const SYSTEMATIC_ISSUERS: &[SystematicIssuers] = &[
    SystematicIssuers::Treasury,
    SystematicIssuers::Committee,
    SystematicIssuers::CDDProvider,
    SystematicIssuers::BlockRewardReserve,
    SystematicIssuers::Settlement,
    SystematicIssuers::ClassicMigration,
    SystematicIssuers::FiatTickersReservation,
    SystematicIssuers::Rewards,
];

impl SystematicIssuers {
    /// Returns the representation of this issuer as a raw public key.
    pub const fn as_bytes(self) -> &'static [u8; 32] {
        use constants::did;
        match self {
            SystematicIssuers::Committee => did::GOVERNANCE_COMMITTEE_DID,
            SystematicIssuers::CDDProvider => did::CDD_PROVIDERS_DID,
            SystematicIssuers::Treasury => did::TREASURY_DID,
            SystematicIssuers::BlockRewardReserve => did::BLOCK_REWARD_RESERVE_DID,
            SystematicIssuers::Settlement => did::SETTLEMENT_MODULE_DID,
            SystematicIssuers::ClassicMigration => did::CLASSIC_MIGRATION_DID,
            SystematicIssuers::FiatTickersReservation => did::FIAT_TICKERS_RESERVATION_DID,
            SystematicIssuers::Rewards => did::REWARDS_DID,
        }
    }

    /// It returns the Identity Identifier of this issuer.
    pub const fn as_id(self) -> IdentityId {
        IdentityId(*self.as_bytes())
    }

    pub const fn as_module_id(self) -> ModuleId {
        match self {
            SystematicIssuers::Committee => constants::GC_MODULE_ID,
            SystematicIssuers::CDDProvider => constants::CDD_MODULE_ID,
            SystematicIssuers::Treasury => constants::TREASURY_MODULE_ID,
            SystematicIssuers::BlockRewardReserve => constants::BRR_MODULE_ID,
            SystematicIssuers::Settlement => constants::SETTLEMENT_MODULE_ID,
            SystematicIssuers::ClassicMigration => constants::CLASSIC_MIGRATION_MODULE_ID,
            SystematicIssuers::FiatTickersReservation => {
                constants::FIAT_TICKERS_RESERVATION_MODULE_ID
            }
            SystematicIssuers::Rewards => constants::REWARDS_MODULE_ID,
        }
    }
}

pub const GC_DID: IdentityId = SystematicIssuers::Committee.as_id();

/// Execute the supplied function in a new storage transaction,
/// committing on `Ok(_)` and rolling back on `Err(_)`, returning the result.
///
/// Transactions can be arbitrarily nested with commits happening to the parent.
pub fn with_transaction<T, E>(tx: impl FnOnce() -> Result<T, E>) -> Result<T, E> {
    use frame_support::storage::{with_transaction, TransactionOutcome};
    with_transaction(|| match tx() {
        r @ Ok(_) => TransactionOutcome::Commit(r),
        r @ Err(_) => TransactionOutcome::Rollback(r),
    })
}

/// In one transaction, execute the supplied function `tx` on each element in `iter`.
///
/// See `with_transaction` for details.
pub fn with_each_transaction<A>(
    iter: impl IntoIterator<Item = A>,
    tx: impl FnMut(A) -> DispatchResult,
) -> DispatchResult {
    with_transaction(|| iter.into_iter().try_for_each(tx))
}

/// Either a block number, or nothing.
#[derive(Copy, Clone, PartialEq, Eq, Encode, Decode, Debug)]
#[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
pub enum MaybeBlock<BlockNumber> {
    Some(BlockNumber),
    None,
}

impl<T> Default for MaybeBlock<T> {
    fn default() -> Self {
        Self::None
    }
}

impl<T: Add<Output = T>> Add<T> for MaybeBlock<T> {
    type Output = Self;
    fn add(self, rhs: T) -> Self::Output {
        match self {
            MaybeBlock::Some(lhs) => MaybeBlock::Some(lhs + rhs),
            MaybeBlock::None => MaybeBlock::None,
        }
    }
}
