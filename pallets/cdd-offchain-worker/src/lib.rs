// This file is part of the Polymesh distribution (https://github.com/PolymathNetwork/Polymesh).
// Copyright (c) 2020 Polymath

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, version 3.

// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

// To make sure we are on the no_std when compiling to wasm
#![cfg_attr(not(feature = "std"), no_std)]

use codec::{Decode, Encode};
use frame_support::{
    debug, decl_error, decl_event, decl_module, decl_storage,
    dispatch::DispatchResult,
    ensure,
    traits::Get,
    weights::{DispatchClass, Pays},
};
use frame_system::{
    self as system, ensure_none,
    offchain::{
        AppCrypto, CreateSignedTransaction, SendUnsignedTransaction, SignedPayload, Signer,
        SigningTypes,
    },
};
use polymesh_common_utilities::traits::offchain::OffchainInterface;
use polymesh_primitives::{Signature, Verify};
use sp_core::crypto::KeyTypeId;
use sp_runtime::transaction_validity::{
    InvalidTransaction, TransactionPriority, TransactionSource, TransactionValidity,
    ValidTransaction,
};
use sp_runtime::{
    traits::{SaturatedConversion, Zero},
    RuntimeDebug,
};
use sp_std::{convert::TryFrom, prelude::*};

/// Defines application identifier for crypto keys of this module.
///
/// Every module that deals with signatures needs to declare its unique identifier for
/// its crypto keys.
/// When off-chain worker is signing transactions it's going to request keys of type
/// `KeyTypeId` from the keystore and use the ones it finds to sign the transaction.
/// The keys can be inserted manually via RPC (see `author_insertKey`).
pub const KEY_TYPE: KeyTypeId = KeyTypeId(*b"cddw");

/// Based on the above `KeyTypeId` we need to generate a pallet-specific crypto type wrappers.
/// We can use from supported crypto kinds (`sr25519`, `ed25519` and `ecdsa`) and augment
/// the types with this pallet-specific identifier.
pub mod crypto {
    use super::{Signature, Verify, KEY_TYPE};
    use frame_system::offchain::AppCrypto;

    mod sr25519_app {
        use sp_application_crypto::{app_crypto, sr25519};
        app_crypto!(sr25519, super::KEY_TYPE);
    }

    pub type SignerId = sr25519_app::Public;

    /// An `AppCrypto` type to allow submitting signed transactions using the reporting
    /// application key as signer.
    pub struct SignerAppCrypto;

    impl AppCrypto<<Signature as Verify>::Signer, Signature> for SignerAppCrypto {
        type RuntimeAppPublic = SignerId;
        type GenericSignature = sp_core::sr25519::Signature;
        type GenericPublic = sp_core::sr25519::Public;
    }
}

pub trait Trait: CreateSignedTransaction<Call<Self>> {
    /// The identifier type for an off-chain worker.
    type AuthorityId: AppCrypto<Self::Public, Self::Signature>;
    /// The overarching event type.
    type Event: From<Event<Self>> + Into<<Self as system::Trait>::Event>;
    /// The overarching dispatch call type.
    type Call: From<Call<Self>>;
    /// No. of blocks delayed to execute the off-chain worker.
    type CoolingInterval: Get<Self::BlockNumber>;
    /// Buffer given to check the validity of the cdd claim. It is in block numbers.
    type BufferInterval: Get<Self::BlockNumber>;
    /// A configuration for base priority of unsigned transactions.
    ///
    /// This is exposed so that it can be tuned for particular runtime, when
    /// multiple pallets send unsigned transactions.
    type UnsignedPriority: Get<TransactionPriority>;
    /// Off-chain interface with staking pallet.
    type StakingInterface: OffchainInterface<<Self as system::Trait>::AccountId>;
}

/// Payload used to hold the invalidate nominators
/// data required to submit a transaction.
#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug)]
pub struct Payload<Public, BlockNumber, AccountId> {
    block_number: BlockNumber,
    nominators: Vec<AccountId>,
    public: Public,
}

impl<T: SigningTypes> SignedPayload<T> for Payload<T::Public, T::BlockNumber, T::AccountId> {
    fn public(&self) -> T::Public {
        self.public.clone()
    }
}

decl_storage! {
    trait Store for Module<T: Trait> as CddOffchainWorker {
        /// Last block at which unsigned transaction get submitted with in the transaction pool
        pub LastExtSubmittedAt get(fn last_extrinsic_submitted_at): T::BlockNumber;
    }
}

decl_event! {
    /// Events generated by the module.
    pub enum Event<T>
        where
        BlockNumber = <T as frame_system::Trait>::BlockNumber,
        AccountId = <T as frame_system::Trait>::AccountId,
    {
        /// Event generated when nominators get removed from the `Staking` storage
        InvalidateNominators(BlockNumber, Vec<AccountId>),
    }
}

decl_module! {
    pub struct Module<T: Trait> for enum Call where origin: T::Origin {
        type Error = Error<T>;

        /// initialize the default event for this module
        fn deposit_event() = default;

        /// Submit the list of invalidate nominators via unsigned transaction.
        ///
        /// we allow sending the transaction without a signature, and hence without paying any fees,
        /// we need a way to make sure that only some transactions are accepted.
        /// This function can be called only once every `T::CoolingInterval` blocks.
        /// Transactions that call that function are de-duplicated on the pool level
        /// via `validate_unsigned` implementation and also are rendered invalid if
        /// the function has already been called in current "session".
        ///
        /// It's important to specify `weight` for unsigned calls as well, because even though
        /// they don't charge fees, we still don't want a single block to contain unlimited
        /// number of such transactions.
        #[weight = (10_000_000, DispatchClass::Operational, Pays::Yes)]
        fn submit_unsigned_invalidate_nominators_with_signed_payload(origin, payload: Payload<T::Public, T::BlockNumber, T::AccountId>, _signature: T::Signature) -> DispatchResult {
            // This is an unsigned transaction so origin should be none
            ensure_none(origin)?;
            // apply a sanity check to know whether the length of target list is greater than 0 or not.
            ensure!(payload.nominators.len() > 0, Error::<T>::EmptyTargetList);
            // call the mutable function that will change the list of nominators in the staking pallet
            T::StakingInterface::unchecked_remove_expired_cdd_nominators(&payload.nominators)?;
            // now change the block number at which this unsigned transaction get executed.
            let current_block = <system::Module<T>>::block_number();
            <LastExtSubmittedAt<T>>::put(current_block);
            Self::deposit_event(RawEvent::InvalidateNominators(
                <frame_system::Module<T>>::block_number(),
                payload.nominators,
            ));
            Ok(())
        }


        fn offchain_worker(block: T::BlockNumber) {
            // Print the debug statement to know that offchain worker initiated
            // Using `native` to avoid increase the size of the WASM blob, Because of this
            // logs will only be printed during native execution only.
            debug::native::info!("Execution of the offchain worker starts!");
            if Self::is_unsigned_transaction_allowed(block) {
                debug::native::info!("Transaction is allowed to execute as cooling interval passed!");
                let res = Self::remove_invalidate_nominators(block);
                if let Err(e) = res {
                    debug::error!("Error: {:?}", e);
                }
            }
        }
    }
}

decl_error! {
    pub enum Error for Module<T: Trait> {
        /// List of invalidate nominators is empty
        EmptyTargetList
    }
}

impl<T: Trait> Module<T> {
    /// Helper function to generate the unsigned transaction to remove
    /// the expired cdd'ed nominators.
    fn remove_invalidate_nominators(block_number: T::BlockNumber) -> DispatchResult {
        debug::native::info!("Execution of invalidate nominators function starts");
        // First we validate whether the transaction proposer is validator or not.
        // if yes then only the invalidate nominators get fetched & transaction get proposed otherwise not.
        ensure!(sp_io::offchain::is_validator(), "Not a validator");

        // Fetch all the nominators whose cdd claim get expired or expiry remaining time is less
        // than the `BufferInterval`. List of the Vec<Stash> get retrieved from the staking module
        let invalid_nominators = T::StakingInterface::fetch_invalid_cdd_nominators(
            (T::BufferInterval::get()).saturated_into::<u64>(),
        );

        // Avoid calling unsigned transaction when invalid nominators length of `invalid_nominators` vector is 0.
        if invalid_nominators.len() > Zero::zero() {
            debug::native::info!("Invalid nominators are fetched from the staking pallet & allowed to execute further: {:?}", invalid_nominators);

            // -- Sign using any accounts
            let (_, result) = Signer::<T, T::AuthorityId>::any_account()
                .send_unsigned_transaction(
                    |account| Payload {
                        block_number,
                        nominators: invalid_nominators.clone(),
                        public: account.public.clone(),
                    },
                    |payload, signature| {
                        Call::submit_unsigned_invalidate_nominators_with_signed_payload(
                            payload, signature,
                        )
                    },
                )
                .ok_or("No local accounts accounts available.")?;
            result.map_err(|()| "Unable to submit transaction")?;
        }
        Ok(())
    }

    fn is_unsigned_transaction_allowed(block_number: T::BlockNumber) -> bool {
        // check whether the last extrinsic submission blockNumber + cooling interval should be
        // greater than current block number or not.
        // It is not recommended to hook unsigned txn in every block because it is a non-deterministic
        // task we are not sure how much time it will take to process. So cooling period is recommended
        // to provide the gap for the execution of non-deterministic task.
        Self::last_extrinsic_submitted_at() + T::CoolingInterval::get() < block_number
    }
}

#[allow(deprecated)]
impl<T: Trait> frame_support::unsigned::ValidateUnsigned for Module<T> {
    type Call = Call<T>;

    /// Validate unsigned call to this module.
    ///
    /// By default unsigned transactions are disallowed, but implementing the validator
    /// here we make sure that some particular calls (the ones produced by offchain worker)
    /// are being exempted and marked as valid.
    fn validate_unsigned(_source: TransactionSource, call: &Self::Call) -> TransactionValidity {
        // Firstly let's check that we call the right function.
        if let Call::submit_unsigned_invalidate_nominators_with_signed_payload(
            ref payload,
            ref signature,
        ) = call
        {
            // Now let's check if the transaction has any chance to succeed.
            let last_unsigned_at = <LastExtSubmittedAt<T>>::get();
            ensure!(
                last_unsigned_at + T::CoolingInterval::get() <= payload.block_number,
                InvalidTransaction::Stale
            );

            // Let's make sure to reject transactions from the future.
            ensure!(
                &<system::Module<T>>::block_number() >= &payload.block_number,
                InvalidTransaction::Future
            );

            // validating signature
            ensure!(
                SignedPayload::<T>::verify::<T::AuthorityId>(payload, signature.clone()),
                InvalidTransaction::BadProof
            );

            ValidTransaction::with_tag_prefix("CddOffchainWorker")
                .priority(T::UnsignedPriority::get().saturating_add(
                    1000 * u64::try_from(payload.nominators.len()).unwrap_or_default(),
                ))
                // The transaction is only valid for next 5 blocks. After that it's
                // going to be revalidated by the pool.
                .longevity(5)
                // Not to be propagated to peer nodes.
                .propagate(false)
                .build()
        } else {
            InvalidTransaction::Call.into()
        }
    }
}
